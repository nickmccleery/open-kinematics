This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  kinematics/
    points/
      derived/
        definitions.py
        manager.py
    suspensions/
      core/
        __init__.py
        collections.py
        geometry.py
        provider.py
        settings.py
      implementations/
        __init__.py
        double_wishbone.py
        macpherson.py
      __init__.py
      registry.py
    vector_utils/
      generic.py
      geometric.py
    visualization/
      debug.py
      main.py
    __init__.py
    cli.py
    constants.py
    constraints.py
    enums.py
    loader.py
    main.py
    solver.py
    state.py
    targets.py
    types.py
tests/
  data/
    geometry.yaml
  integration/
    test_run_with_viz.py
  points/
    test_derived.py
  vector_utils/
    test_vector_utils_geometric.py
  conftest.py
  test_absolute_mode.py
  test_constraints.py
  test_loader.py
  test_public_api.py
  test_solver.py
  test_state.py
  test_targets.py
.gitignore
.python-version
justfile
PROVENANCE.md
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/integration/test_run_with_viz.py">
from pathlib import Path

import numpy as np
import pytest

from kinematics.constants import TEST_TOLERANCE
from kinematics.constraints import DistanceConstraint
from kinematics.enums import Axis, PointID, TargetPositionMode
from kinematics.loader import load_geometry
from kinematics.main import solve_suspension_sweep
from kinematics.points.derived.manager import DerivedPointsManager
from kinematics.solver import PointTarget
from kinematics.suspensions.implementations.double_wishbone import (
    DoubleWishboneGeometry,
)
from kinematics.types import PointTargetAxis, SweepConfig
from kinematics.visualization.debug import create_animation
from kinematics.visualization.main import SuspensionVisualizer, WheelVisualization

# Our actual solve tolerance is a OOM tighter than this, so should be good.


@pytest.fixture
def displacements():
    n_steps = 31

    hub_range = [-30, 90]
    hub_displacements = list(np.linspace(hub_range[0], hub_range[1], n_steps))

    steer_range = [-30, 30]
    steer_displacements = list(np.linspace(steer_range[0], steer_range[1], n_steps))

    return hub_displacements, steer_displacements


@pytest.fixture
def sweep_config_fixture(displacements):
    hub_displacements, steer_displacements = displacements

    # Create hub displacement sweep.
    hub_targets = [
        PointTarget(
            point_id=PointID.WHEEL_CENTER,
            direction=PointTargetAxis(Axis.Z),
            value=x,
            mode=TargetPositionMode.RELATIVE,
        )
        for x in hub_displacements
    ]

    # Create steer sweep.
    steer_targets = [
        PointTarget(
            point_id=PointID.TRACKROD_INBOARD,
            direction=PointTargetAxis(Axis.Y),
            value=x,
            mode=TargetPositionMode.RELATIVE,
        )
        for x in steer_displacements
    ]

    # Create sweep config.
    sweep_config = SweepConfig([hub_targets, steer_targets])

    return sweep_config


def test_run_solver(
    double_wishbone_geometry_file: Path, sweep_config_fixture, displacements
) -> None:
    hub_displacements, _ = displacements

    loaded = load_geometry(double_wishbone_geometry_file)
    if not isinstance(loaded.geometry, DoubleWishboneGeometry):
        raise ValueError("Invalid geometry type")

    # Solve for all positions.
    position_states = solve_suspension_sweep(
        loaded.geometry, loaded.provider_cls, sweep_config_fixture
    )

    print("Solve complete, verifying constraints...")

    # Get initial positions for comparison using the provider.

    provider = loaded.provider_cls(loaded.geometry)  # type: ignore[call-arg]
    derived_resolver = DerivedPointsManager(provider.derived_spec())

    initial_state = provider.initial_state()
    derived_resolver.update_in_place(initial_state.positions)
    initial_positions = initial_state.positions.copy()

    # Get only the length constraints for verification
    all_constraints = provider.constraints()

    length_constraints = [
        c for c in all_constraints if isinstance(c, DistanceConstraint)
    ]
    target_point_id = PointID.WHEEL_CENTER

    # Verify constraints are maintained.
    for state, displacement in zip(position_states, hub_displacements):
        # Verify length constraints.
        for constraint in length_constraints:
            p1 = state.positions[constraint.p1]
            p2 = state.positions[constraint.p2]
            current_length = np.linalg.norm(p1 - p2)

            assert (
                np.abs(current_length - constraint.target_distance) < TEST_TOLERANCE
            ), (
                f"Constraint violation at displacement {displacement}: "
                f"{constraint.p1.name} to {constraint.p2.name}"
            )

        # Verify target point z position.
        target_point_position = state.positions[target_point_id]
        initial_target_point_position = initial_positions[target_point_id]
        target_z = initial_target_point_position[2] + displacement

        assert np.abs(target_point_position[2] - target_z) < TEST_TOLERANCE, (
            f"Failed to maintain {target_point_id} at displacement {displacement}"
        )

    print("Creating animation...")

    # Extract positions from SuspensionState objects for animation
    position_states_positions = [state.positions for state in position_states]
    position_states_animate = (
        position_states_positions + position_states_positions[::-1]
    )
    output_path = Path("suspension_motion.gif")

    r_aspect = 0.55
    x_section = 270
    x_diameter = 13 * 25.4

    wheel_config = WheelVisualization(
        diameter=x_diameter + r_aspect * x_section * 2,
        width=225,
    )

    visualizer = SuspensionVisualizer(loaded.geometry, wheel_config)
    create_animation(
        position_states_animate, initial_positions, visualizer, output_path
    )
</file>

<file path="tests/vector_utils/test_vector_utils_geometric.py">
import numpy as np

from kinematics.vector_utils.generic import normalize_vector
from kinematics.vector_utils.geometric import (
    compute_point_point_distance,
    compute_point_point_midpoint,
    compute_vector_vector_angle,
)


def test_point_distance():
    p1 = np.array([0.0, 0.0, 0.0])
    p2 = np.array([1.0, 0.0, 0.0])
    assert compute_point_point_distance(p1, p2) == 1.0

    p3 = np.array([1.0, 1.0, 1.0])
    assert np.isclose(compute_point_point_distance(p1, p3), np.sqrt(3.0))


def test_compute_midpoint():
    p1 = np.array([0.0, 0.0, 0.0])
    p2 = np.array([2.0, 4.0, 6.0])
    mid = compute_point_point_midpoint(p1, p2)
    np.testing.assert_array_equal(mid, np.array([1.0, 2.0, 3.0]))


def test_normalize_vector():
    v = np.array([3.0, 0.0, 4.0])
    norm = normalize_vector(v)
    assert np.isclose(np.linalg.norm(norm), 1.0)
    np.testing.assert_array_almost_equal(norm, np.array([0.6, 0.0, 0.8]))


def test_compute_vector_angle():
    v1 = np.array([1.0, 0.0, 0.0])
    v2 = np.array([0.0, 1.0, 0.0])
    angle = compute_vector_vector_angle(v1, v2)
    assert np.isclose(angle, np.pi / 2)
</file>

<file path="tests/test_state.py">
import numpy as np

from kinematics.enums import PointID
from kinematics.state import SuspensionState


def test_suspension_state_construction():
    # Test data setup.
    positions_data = {
        PointID.LOWER_WISHBONE_OUTBOARD: np.array([1.0, 2.0, 3.0]),
        PointID.UPPER_WISHBONE_OUTBOARD: np.array([4.0, 5.0, 6.0]),
    }
    free_points = {PointID.LOWER_WISHBONE_OUTBOARD}

    # Create state.
    state = SuspensionState(positions=positions_data, free_points=free_points)

    # Verify positions are stored correctly.
    np.testing.assert_array_equal(
        state.positions[PointID.LOWER_WISHBONE_OUTBOARD], np.array([1.0, 2.0, 3.0])
    )

    # Verify free points are stored.
    assert state.free_points == {PointID.LOWER_WISHBONE_OUTBOARD}

    # Verify fixed points are computed correctly.
    assert state.fixed_points == {PointID.UPPER_WISHBONE_OUTBOARD}


def test_suspension_state_array_conversion():
    """
    Test the array conversion methods in SuspensionState.
    """
    positions_data = {
        PointID.LOWER_WISHBONE_OUTBOARD: np.array([1.0, 2.0, 3.0]),
        PointID.UPPER_WISHBONE_OUTBOARD: np.array([4.0, 5.0, 6.0]),
    }
    free_points = {PointID.LOWER_WISHBONE_OUTBOARD, PointID.UPPER_WISHBONE_OUTBOARD}

    # Create state
    state = SuspensionState(positions=positions_data, free_points=free_points)

    # Test extraction
    arr = state.get_free_array()
    # Should be sorted order: LOWER_WISHBONE_OUTBOARD, UPPER_WISHBONE_OUTBOARD
    expected_flat = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
    np.testing.assert_array_equal(arr, expected_flat)

    # Test update from array
    new_array = np.array([7.0, 8.0, 9.0, 10.0, 11.0, 12.0])
    state.update_from_array(new_array)

    # Verify positions were updated
    np.testing.assert_array_equal(
        state.positions[PointID.LOWER_WISHBONE_OUTBOARD], np.array([7.0, 8.0, 9.0])
    )
    np.testing.assert_array_equal(
        state.positions[PointID.UPPER_WISHBONE_OUTBOARD], np.array([10.0, 11.0, 12.0])
    )
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/
</file>

<file path=".python-version">
3.12
</file>

<file path="README.md">
# suspension-kinematics
</file>

<file path="src/kinematics/suspensions/core/__init__.py">
"""
Core suspension abstractions.
"""

from kinematics.suspensions.core.geometry import SuspensionGeometry
from kinematics.suspensions.core.provider import SuspensionProvider

__all__ = ["SuspensionGeometry", "SuspensionProvider"]
</file>

<file path="src/kinematics/suspensions/core/collections.py">
"""
Common suspension component point collections.

This module defines dataclasses for point collections which are shared across suspension
architectures.
"""

from dataclasses import dataclass


@dataclass
class LowerWishbonePoints:
    """
    Points defining the lower wishbone geometry.

    Attributes:
        inboard_front: Front inboard mounting point coordinates.
        inboard_rear: Rear inboard mounting point coordinates.
        outboard: Outboard mounting point coordinates.
    """

    inboard_front: dict[str, float]
    inboard_rear: dict[str, float]
    outboard: dict[str, float]


@dataclass
class UpperWishbonePoints:
    """
    Points defining the upper wishbone geometry.

    Attributes:
        inboard_front: Front inboard mounting point coordinates.
        inboard_rear: Rear inboard mounting point coordinates.
        outboard: Outboard mounting point coordinates.
    """

    inboard_front: dict[str, float]
    inboard_rear: dict[str, float]
    outboard: dict[str, float]


@dataclass
class WheelAxlePoints:
    """
    Points defining the wheel axle geometry.

    Attributes:
        inner: Inner axle point coordinates.
        outer: Outer axle point coordinates.
    """

    inner: dict[str, float]
    outer: dict[str, float]


@dataclass
class TrackRodPoints:
    """
    Points defining the track rod/tie rod geometry.

    Attributes:
        inner: Inner track rod mounting point coordinates.
        outer: Outer track rod mounting point coordinates.
    """

    inner: dict[str, float]
    outer: dict[str, float]
</file>

<file path="src/kinematics/suspensions/core/provider.py">
"""
Base classes for suspension providers.

This module defines the abstract interface for suspension providers that bind geometry
models to kinematic states, constraints, and derived point calculations.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Sequence

from kinematics.constraints import Constraint
from kinematics.enums import PointID
from kinematics.points.derived.manager import DerivedPointsSpec
from kinematics.state import SuspensionState


class SuspensionProvider(ABC):
    """
    Abstract base class for suspension providers.

    Suspension providers bind concrete geometry models to the kinematic framework by
    providing initial states, free points, derived point specifications, and geometric
    constraints.
    """

    @abstractmethod
    def initial_state(self) -> SuspensionState:
        """
        Get the initial suspension state.

        Returns:
            The starting configuration of all points in the suspension.
        """
        ...

    @abstractmethod
    def free_points(self) -> Sequence[PointID]:
        """
        Get the points that can move during solving.

        Returns:
            Sequence of point IDs that are free to move.
        """
        ...

    @abstractmethod
    def derived_spec(self) -> DerivedPointsSpec:
        """
        Get the specification for computing derived points.

        Returns:
            Specification defining how derived points are calculated from free points.
        """
        ...

    @abstractmethod
    def constraints(self) -> list[Constraint]:
        """
        Get the geometric constraints for the suspension.

        Returns:
            List of constraints that must be satisfied during solving.
        """
        ...
</file>

<file path="src/kinematics/suspensions/implementations/__init__.py">
"""
Concrete suspension implementations.
"""

from kinematics.suspensions.implementations.double_wishbone import (
    DoubleWishboneGeometry,
    DoubleWishboneProvider,
)
from kinematics.suspensions.implementations.macpherson import (
    MacPhersonGeometry,
    MacPhersonProvider,
)

__all__ = [
    "DoubleWishboneGeometry",
    "DoubleWishboneProvider",
    "MacPhersonGeometry",
    "MacPhersonProvider",
]
</file>

<file path="src/kinematics/enums.py">
"""
Enumeration types for suspension kinematics.
"""

from enum import Enum, IntEnum


class PointID(IntEnum):
    """
    Enumeration of all point identifiers used in the suspension system.
    """

    NOT_ASSIGNED = 0

    LOWER_WISHBONE_INBOARD_FRONT = 1
    LOWER_WISHBONE_INBOARD_REAR = 2
    LOWER_WISHBONE_OUTBOARD = 3

    UPPER_WISHBONE_INBOARD_FRONT = 4
    UPPER_WISHBONE_INBOARD_REAR = 5
    UPPER_WISHBONE_OUTBOARD = 6

    PUSHROD_INBOARD = 7
    PUSHROD_OUTBOARD = 8

    TRACKROD_INBOARD = 9
    TRACKROD_OUTBOARD = 10

    AXLE_INBOARD = 11
    AXLE_OUTBOARD = 12
    AXLE_MIDPOINT = 13

    STRUT_INBOARD = 14
    STRUT_OUTBOARD = 15

    WHEEL_CENTER = 16
    WHEEL_INBOARD = 17
    WHEEL_OUTBOARD = 18


class Axis(IntEnum):
    """
    Enumeration of the three principal axes in 3D space.
    """

    X = 0
    Y = 1
    Z = 2


class TargetPositionMode(Enum):
    """
    Specifies how a target value should be interpreted.
    """

    RELATIVE = "relative"
    ABSOLUTE = "absolute"


class Units(Enum):
    """
    Units of measurement for geometric parameters.
    """

    MILLIMETERS = "millimeters"
</file>

<file path="tests/data/geometry.yaml">
type: "DOUBLE_WISHBONE"
name: "test"
version: "0.0.1"
units: "MILLIMETERS"

hard_points:
  lower_wishbone:
    inboard_front:
      x: 250
      y: 400
      z: 0
    inboard_rear:
      x: -250
      y: 450
      z: 0
    outboard:
      x: 0
      y: 900
      z: 0
  upper_wishbone:
    inboard_front:
      x: 225
      y: 350
      z: 275
    inboard_rear:
      x: -275
      y: 350
      z: 275
    outboard:
      x: -25
      y: 750
      z: 300
  wheel_axle:
    # Axle outer point is the hub face.
    inner:
      x: -20
      y: 800
      z: 150
    outer:
      x: -20
      y: 950
      z: 150
  track_rod:
    inner:
      x: 50
      y: 200
      z: 100
    outer:
      x: 100
      y: 700
      z: 100
configuration:
  steered: true
  wheel:
    diameter: 457.2
    width: 225.0
    offset: 0
  static_setup:
    static_camber: -3.0
    static_toe: 0.0
    static_caster: 5.0
</file>

<file path="tests/conftest.py">
from pathlib import Path

import pytest


@pytest.fixture
def test_data_dir() -> Path:
    return Path(__file__).parent / "data"


@pytest.fixture
def double_wishbone_geometry_file(test_data_dir: Path) -> Path:
    return test_data_dir / "geometry.yaml"
</file>

<file path="tests/test_public_api.py">
# tests/test_public_api.py
import importlib
import sys


def test_public_api_exports():
    km = importlib.import_module("kinematics")
    expected = {
        "load_geometry",
        "solve",
        "solve_sweep",
        "PointID",
        "PointTarget",
        "SweepConfig",
        "Constraint",
        "SolverConfig",
    }
    assert expected.issubset(set(dir(km)))


def test_no_matplotlib_import_on_core():
    # ensure matplotlib is not pulled in by importing kinematics
    sys.modules.pop("matplotlib", None)
    import importlib

    importlib.invalidate_caches()
    importlib.import_module("kinematics")  # noqa: F401
    assert "matplotlib" not in sys.modules
</file>

<file path="justfile">
# Setup development environment.
setup:
    uv venv
    uv sync --all-extras --dev
    uv pip install -e .

# Install dependencies only.
install:
    uv sync --all-extras --dev
    uv pip install -e .

# Clean.
clean:
    rm -rf .venv
    rm -rf .pytest_cache
    rm -rf .ruff_cache
    rm -rf dist
    rm -rf build
    rm -rf *.egg-info
    find . -type d -name __pycache__ -exec rm -rf {} +

# Testing.
test:
    uv run pytest tests/

# Linting.
lint:
    uv run ruff check .
    uv run ty check .

# Formatting. Note that the docformatter config is defined in pyproject.toml.
# The `|| true` is to ignore the non-zero exit code when no files are found to
# format.
format:
    uv run ruff format .
    uv run docformatter --in-place --recursive . || true
</file>

<file path="PROVENANCE.md">
Derived from  at commit
</file>

<file path="src/kinematics/suspensions/core/geometry.py">
"""
Base classes for suspension geometry.

This module defines the abstract base classes that all suspension geometries must
implement. These classes provide the common interface and structure for representing
different types of suspension systems in the kinematics framework.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass

from kinematics.enums import Units
from kinematics.suspensions.core.settings import SuspensionConfig


@dataclass
class SuspensionGeometry(ABC):
    """
    Base class for all suspension geometry types.

    Attributes:
        name: Human-readable name of the suspension geometry.
        version: Version string of the geometry implementation.
        units: Unit system used for all measurements and calculations.
        configuration: Detailed configuration parameters for the suspension.
    """

    name: str
    version: str
    units: Units
    configuration: SuspensionConfig

    @abstractmethod
    def validate(self) -> bool:
        """
        Validate the suspension geometry configuration. This method should perform
        checks to ensure the geometry is properly configured.

        Returns:
            True if the geometry is valid, False otherwise.
        """
        raise NotImplementedError
</file>

<file path="src/kinematics/suspensions/core/settings.py">
"""
Suspension configuration classes and enums.

This module defines configuration structures for suspension systems, including units,
wheel parameters, and static alignment settings.
"""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class WheelConfig:
    """
    Configuration parameters for a wheel.

    Attributes:
        diameter: Wheel diameter in specified units.
        width: Wheel width in specified units.
        offset: Wheel offset from mounting surface.
    """

    diameter: float
    width: float
    offset: float


@dataclass
class StaticSetupConfig:
    """
    Static alignment configuration for a suspension.

    Attributes:
        static_camber: Static camber angle in degrees.
        static_toe: Static toe angle in degrees.
        static_caster: Static caster angle in degrees.
    """

    static_camber: float
    static_toe: float
    static_caster: float


@dataclass
class SuspensionConfig:
    """
    Complete configuration for a suspension system.

    Attributes:
        steered: Whether this suspension corner is steered.
        wheel: Wheel configuration parameters.
        static_setup: Static alignment settings.
    """

    steered: bool
    wheel: WheelConfig
    static_setup: StaticSetupConfig
</file>

<file path="src/kinematics/suspensions/implementations/double_wishbone.py">
"""
Double wishbone suspension implementation.
"""

from dataclasses import dataclass
from functools import partial
from typing import Sequence

import numpy as np

from kinematics.constraints import (
    AngleConstraint,
    Constraint,
    DistanceConstraint,
    PointOnLineConstraint,
)
from kinematics.enums import PointID
from kinematics.points.derived.definitions import (
    get_axle_midpoint,
    get_wheel_center,
    get_wheel_inboard,
    get_wheel_outboard,
)
from kinematics.points.derived.manager import DerivedPointsManager, DerivedPointsSpec
from kinematics.state import SuspensionState
from kinematics.suspensions.core.collections import (
    LowerWishbonePoints,
    TrackRodPoints,
    UpperWishbonePoints,
    WheelAxlePoints,
)
from kinematics.suspensions.core.geometry import SuspensionGeometry
from kinematics.suspensions.core.provider import SuspensionProvider
from kinematics.vector_utils.geometric import (
    compute_point_point_distance,
    compute_vector_vector_angle,
)


@dataclass
class DoubleWishboneHardPoints:
    """
    Hard point collection for double wishbone suspension.

    Attributes:
        lower_wishbone: Points defining the lower wishbone geometry.
        upper_wishbone: Points defining the upper wishbone geometry.
        track_rod: Points defining the track rod geometry.
        wheel_axle: Points defining the wheel axle geometry.
    """

    lower_wishbone: LowerWishbonePoints
    upper_wishbone: UpperWishbonePoints
    track_rod: TrackRodPoints
    wheel_axle: WheelAxlePoints


# Geometry model
@dataclass
class DoubleWishboneGeometry(SuspensionGeometry):
    """
    Double wishbone suspension geometry definition.

    Extends the base SuspensionGeometry with double wishbone specific hard points.

    Attributes:
        hard_points: Collection of all hard point coordinates for the suspension.
    """

    hard_points: DoubleWishboneHardPoints

    def validate(self) -> bool:
        """
        Validate the double wishbone geometry configuration.

        Returns:
            True if geometry is valid.
        """
        # ! TODO: Actually validate this geometry.
        return True


# Provider implementation
class DoubleWishboneProvider(SuspensionProvider):
    """
    Concrete implementation of SuspensionProvider for double wishbone geometry.
    """

    def __init__(self, geometry: DoubleWishboneGeometry):
        """
        Initialize the double wishbone provider.

        Args:
            geometry: Double wishbone geometry configuration.
        """
        self.geometry = geometry

    def initial_state(self) -> SuspensionState:
        """
        Create initial suspension state from geometry hard points.

        Converts the hard point coordinates from the geometry into a SuspensionState
        with both explicitly defined and derived points.

        Returns:
            Initial suspension state with all point positions.
        """
        positions = {}
        hard_points = self.geometry.hard_points

        # Lower wishbone.
        lwb = hard_points.lower_wishbone
        positions[PointID.LOWER_WISHBONE_INBOARD_FRONT] = np.array(
            [lwb.inboard_front["x"], lwb.inboard_front["y"], lwb.inboard_front["z"]]
        )
        positions[PointID.LOWER_WISHBONE_INBOARD_REAR] = np.array(
            [lwb.inboard_rear["x"], lwb.inboard_rear["y"], lwb.inboard_rear["z"]]
        )
        positions[PointID.LOWER_WISHBONE_OUTBOARD] = np.array(
            [lwb.outboard["x"], lwb.outboard["y"], lwb.outboard["z"]]
        )

        # Upper wishbone.
        uwb = hard_points.upper_wishbone
        positions[PointID.UPPER_WISHBONE_INBOARD_FRONT] = np.array(
            [uwb.inboard_front["x"], uwb.inboard_front["y"], uwb.inboard_front["z"]]
        )
        positions[PointID.UPPER_WISHBONE_INBOARD_REAR] = np.array(
            [uwb.inboard_rear["x"], uwb.inboard_rear["y"], uwb.inboard_rear["z"]]
        )
        positions[PointID.UPPER_WISHBONE_OUTBOARD] = np.array(
            [uwb.outboard["x"], uwb.outboard["y"], uwb.outboard["z"]]
        )

        # Track rod.
        tr = hard_points.track_rod
        positions[PointID.TRACKROD_INBOARD] = np.array(
            [tr.inner["x"], tr.inner["y"], tr.inner["z"]]
        )
        positions[PointID.TRACKROD_OUTBOARD] = np.array(
            [tr.outer["x"], tr.outer["y"], tr.outer["z"]]
        )

        # Wheel axle
        wa = hard_points.wheel_axle
        positions[PointID.AXLE_INBOARD] = np.array(
            [wa.inner["x"], wa.inner["y"], wa.inner["z"]]
        )
        positions[PointID.AXLE_OUTBOARD] = np.array(
            [wa.outer["x"], wa.outer["y"], wa.outer["z"]]
        )

        # Calculate derived points to create a complete initial state.
        derived_spec = self.derived_spec()
        derived_resolver = DerivedPointsManager(derived_spec)
        derived_resolver.update_in_place(positions)

        return SuspensionState(positions=positions, free_points=set(self.free_points()))

    def free_points(self) -> Sequence[PointID]:
        """
        Define which points the solver can move during optimization.

        Returns:
            Sequence of point IDs that are free to move (outboard and axle points).
        """
        return [
            PointID.UPPER_WISHBONE_OUTBOARD,
            PointID.LOWER_WISHBONE_OUTBOARD,
            PointID.AXLE_INBOARD,
            PointID.AXLE_OUTBOARD,
            PointID.TRACKROD_OUTBOARD,
            PointID.TRACKROD_INBOARD,
        ]

    def derived_spec(self) -> DerivedPointsSpec:
        """
        Define specifications for computing derived points from free points.

        Returns:
            Specification containing functions and dependencies for derived points.
        """
        wheel_cfg = self.geometry.configuration.wheel

        functions = {
            PointID.AXLE_MIDPOINT: get_axle_midpoint,
            PointID.WHEEL_CENTER: partial(
                get_wheel_center, wheel_offset=wheel_cfg.offset
            ),
            PointID.WHEEL_INBOARD: partial(
                get_wheel_inboard, wheel_width=wheel_cfg.width
            ),
            PointID.WHEEL_OUTBOARD: partial(
                get_wheel_outboard, wheel_width=wheel_cfg.width
            ),
        }

        dependencies = {
            PointID.AXLE_MIDPOINT: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
            PointID.WHEEL_CENTER: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
            PointID.WHEEL_INBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
            PointID.WHEEL_OUTBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
        }

        return DerivedPointsSpec(functions=functions, dependencies=dependencies)

    def constraints(self) -> list[Constraint]:
        """
        Build the complete set of geometric constraints for double wishbone suspension.

        Returns:
            List of constraints that must be satisfied during kinematic solving.
        """
        constraints: list[Constraint] = []
        initial_state = self.initial_state()

        # Distance constraints.
        length_pairs = [
            (PointID.UPPER_WISHBONE_INBOARD_FRONT, PointID.UPPER_WISHBONE_OUTBOARD),
            (PointID.UPPER_WISHBONE_INBOARD_REAR, PointID.UPPER_WISHBONE_OUTBOARD),
            (PointID.LOWER_WISHBONE_INBOARD_FRONT, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.LOWER_WISHBONE_INBOARD_REAR, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.UPPER_WISHBONE_OUTBOARD, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.UPPER_WISHBONE_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.AXLE_OUTBOARD, PointID.UPPER_WISHBONE_OUTBOARD),
            (PointID.AXLE_OUTBOARD, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.TRACKROD_INBOARD, PointID.TRACKROD_OUTBOARD),
            (PointID.UPPER_WISHBONE_OUTBOARD, PointID.TRACKROD_OUTBOARD),
            (PointID.LOWER_WISHBONE_OUTBOARD, PointID.TRACKROD_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.TRACKROD_OUTBOARD),
            (PointID.AXLE_OUTBOARD, PointID.TRACKROD_OUTBOARD),
        ]
        for p1, p2 in length_pairs:
            target_distance = compute_point_point_distance(
                initial_state.positions[p1], initial_state.positions[p2]
            )
            constraints.append(DistanceConstraint(p1, p2, target_distance))

        # Angle constraints.
        v1 = (
            initial_state.positions[PointID.LOWER_WISHBONE_OUTBOARD]
            - initial_state.positions[PointID.UPPER_WISHBONE_OUTBOARD]
        )
        v2 = (
            initial_state.positions[PointID.AXLE_OUTBOARD]
            - initial_state.positions[PointID.AXLE_INBOARD]
        )
        target_angle = compute_vector_vector_angle(v1, v2)

        constraints.append(
            AngleConstraint(
                v1_start=PointID.UPPER_WISHBONE_OUTBOARD,
                v1_end=PointID.LOWER_WISHBONE_OUTBOARD,
                v2_start=PointID.AXLE_INBOARD,
                v2_end=PointID.AXLE_OUTBOARD,
                target_angle=target_angle,
            )
        )

        # Point-on-line constraints.
        constraints.append(
            PointOnLineConstraint(
                point_id=PointID.TRACKROD_INBOARD,
                line_point=initial_state.positions[PointID.TRACKROD_INBOARD],
                line_direction=np.array([0.0, 1.0, 0.0], dtype=np.float64),
            )
        )

        return constraints
</file>

<file path="src/kinematics/suspensions/implementations/macpherson.py">
"""
MacPherson strut suspension implementation.
"""

from dataclasses import dataclass
from functools import partial
from typing import Sequence

import numpy as np

from kinematics.constraints import Constraint, DistanceConstraint
from kinematics.enums import PointID
from kinematics.points.derived.definitions import (
    get_axle_midpoint,
    get_wheel_center,
    get_wheel_inboard,
    get_wheel_outboard,
)
from kinematics.points.derived.manager import DerivedPointsManager, DerivedPointsSpec
from kinematics.state import SuspensionState
from kinematics.suspensions.core.collections import LowerWishbonePoints, WheelAxlePoints
from kinematics.suspensions.core.geometry import SuspensionGeometry
from kinematics.suspensions.core.provider import SuspensionProvider
from kinematics.vector_utils.geometric import compute_point_point_distance


@dataclass
class StrutPoints:
    """
    Points defining the strut geometry.

    Attributes:
        inboard: Inboard strut mounting point coordinates.
        outboard: Outboard strut mounting point coordinates.
    """

    inboard: dict[str, float]
    outboard: dict[str, float]


@dataclass
class MacPhersonHardPoints:
    """
    Hard point collection for MacPherson strut suspension.

    Attributes:
        lower_wishbone: Points defining the lower wishbone geometry.
        strut: Points defining the strut geometry.
        wheel_axle: Points defining the wheel axle geometry.
    """

    lower_wishbone: LowerWishbonePoints
    strut: StrutPoints
    wheel_axle: WheelAxlePoints


# Geometry model
@dataclass
class MacPhersonGeometry(SuspensionGeometry):
    """
    MacPherson strut suspension geometry definition.

    Extends the base SuspensionGeometry with MacPherson specific hard points.

    Attributes:
        hard_points: Collection of all hard point coordinates for the suspension.
    """

    hard_points: MacPhersonHardPoints

    def validate(self) -> bool:
        """
        Validate the MacPherson geometry configuration.

        Returns:
            True if geometry is valid.
        """
        # ! TODO: Actually validate this geometry.
        return True


# Provider implementation
class MacPhersonProvider(SuspensionProvider):
    """
    Concrete implementation of SuspensionProvider for MacPherson strut geometry.
    """

    def __init__(self, geometry: MacPhersonGeometry):
        """
        Initialize the MacPherson provider.

        Args:
            geometry: MacPherson geometry configuration.
        """
        self.geometry = geometry

    def initial_state(self) -> SuspensionState:
        """
        Create initial suspension state from geometry hard points.

        Converts the hard point coordinates from the geometry into a SuspensionState
        with both explicitly defined and derived points.

        Returns:
            Initial suspension state with all point positions.
        """
        positions = {}
        hard_points = self.geometry.hard_points

        # Lower wishbone.
        lwb = hard_points.lower_wishbone
        positions[PointID.LOWER_WISHBONE_INBOARD_FRONT] = np.array(
            [lwb.inboard_front["x"], lwb.inboard_front["y"], lwb.inboard_front["z"]]
        )
        positions[PointID.LOWER_WISHBONE_INBOARD_REAR] = np.array(
            [lwb.inboard_rear["x"], lwb.inboard_rear["y"], lwb.inboard_rear["z"]]
        )
        positions[PointID.LOWER_WISHBONE_OUTBOARD] = np.array(
            [lwb.outboard["x"], lwb.outboard["y"], lwb.outboard["z"]]
        )

        # Strut.
        strut = hard_points.strut
        positions[PointID.STRUT_INBOARD] = np.array(
            [strut.inboard["x"], strut.inboard["y"], strut.inboard["z"]]
        )
        positions[PointID.STRUT_OUTBOARD] = np.array(
            [strut.outboard["x"], strut.outboard["y"], strut.outboard["z"]]
        )

        # Wheel axle.
        wa = hard_points.wheel_axle
        positions[PointID.AXLE_INBOARD] = np.array(
            [wa.inner["x"], wa.inner["y"], wa.inner["z"]]
        )
        positions[PointID.AXLE_OUTBOARD] = np.array(
            [wa.outer["x"], wa.outer["y"], wa.outer["z"]]
        )

        # Calculate derived points to create a complete initial state.
        derived_spec = self.derived_spec()
        derived_resolver = DerivedPointsManager(derived_spec)
        derived_resolver.update_in_place(positions)

        return SuspensionState(positions=positions, free_points=set(self.free_points()))

    def free_points(self) -> Sequence[PointID]:
        """
        Define which points the solver can move during optimization.

        Returns:
            Sequence of point IDs that are free to move.
        """
        return [
            PointID.LOWER_WISHBONE_OUTBOARD,
            PointID.STRUT_OUTBOARD,
            PointID.AXLE_INBOARD,
            PointID.AXLE_OUTBOARD,
        ]

    def derived_spec(self) -> DerivedPointsSpec:
        """
        Define specifications for computing derived points from free points.

        Returns:
            Specification containing functions and dependencies for derived points.
        """
        wheel_cfg = self.geometry.configuration.wheel

        functions = {
            PointID.AXLE_MIDPOINT: get_axle_midpoint,
            PointID.WHEEL_CENTER: partial(
                get_wheel_center, wheel_offset=wheel_cfg.offset
            ),
            PointID.WHEEL_INBOARD: partial(
                get_wheel_inboard, wheel_width=wheel_cfg.width
            ),
            PointID.WHEEL_OUTBOARD: partial(
                get_wheel_outboard, wheel_width=wheel_cfg.width
            ),
        }

        dependencies = {
            PointID.AXLE_MIDPOINT: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
            PointID.WHEEL_CENTER: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
            PointID.WHEEL_INBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
            PointID.WHEEL_OUTBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
        }

        return DerivedPointsSpec(functions=functions, dependencies=dependencies)

    def constraints(self) -> list[Constraint]:
        """
        Build the complete set of geometric constraints for MacPherson strut suspension.

        Returns:
            List of constraints that must be satisfied during kinematic solving.
        """
        constraints: list[Constraint] = []
        initial_state = self.initial_state()

        # Distance constraints.
        length_pairs = [
            (PointID.LOWER_WISHBONE_INBOARD_FRONT, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.LOWER_WISHBONE_INBOARD_REAR, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.STRUT_INBOARD, PointID.STRUT_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.AXLE_OUTBOARD, PointID.LOWER_WISHBONE_OUTBOARD),
            (PointID.AXLE_INBOARD, PointID.STRUT_OUTBOARD),
            (PointID.AXLE_OUTBOARD, PointID.STRUT_OUTBOARD),
        ]
        for p1, p2 in length_pairs:
            target_distance = compute_point_point_distance(
                initial_state.positions[p1], initial_state.positions[p2]
            )
            constraints.append(DistanceConstraint(p1, p2, target_distance))

        return constraints
</file>

<file path="src/kinematics/suspensions/__init__.py">

</file>

<file path="src/kinematics/vector_utils/generic.py">
"""
Generic vector utility functions.

This module provides fundamental vector operations used throughout the kinematics
system, including normalization, projection, and coordinate transformations. These
operations do not use any types specific to this project, so can be used in utility
contexts without introducing circular dependencies.
"""

import numpy as np
from numpy.typing import NDArray

from kinematics.constants import EPSILON


def normalize_vector(v: NDArray[np.float64]) -> NDArray[np.float64]:
    """
    Normalize a vector of any dimension to a unit vector.

    Args:
        v: Input vector of any dimension.

    Returns:
        Unit vector in the same direction as the input.

    Raises:
        ValueError: If the input vector has zero length (magnitude < EPSILON).
    """
    norm = np.linalg.norm(v)
    if norm < EPSILON:
        raise ValueError("Cannot normalize zero-length vector")
    return (v / norm).astype(np.float64)


def project_coordinate(position: np.ndarray, direction: np.ndarray) -> float:
    """
    Computes the scalar coordinate of a position vector along a unit direction. This
    represents the signed distance of the position along the given direction.

    Args:
        position: The 3D position vector.
        direction: The unit direction vector (magnitude must be 1).

    Returns:
        The scalar projection value.

    Raises:
        ValueError: If direction is not a unit vector.
    """
    if not np.isclose(np.linalg.norm(direction), 1.0, atol=EPSILON):
        raise ValueError(
            f"Direction vector not normalized; magnitude {np.linalg.norm(direction)}"
        )
    return float(np.dot(position, direction))
</file>

<file path="src/kinematics/state.py">
"""
Core state management for suspension kinematics.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Set

import numpy as np

from kinematics.enums import PointID
from kinematics.types import Vec3


@dataclass
class SuspensionState:
    """
    Represents the complete state of a suspension system.

    This class manages point positions and solver metadata, providing methods
    for state manipulation, solver integration, and coordinate transformations.

    Attributes:
        positions (dict[PointID, Vec3]): Dictionary mapping point IDs to 3D positions.
        free_points (Set[PointID]): Set of point IDs that are free to move during solving.
        free_points_order (List[PointID]): Sorted list of free point IDs for consistent ordering.
    """

    positions: dict[PointID, Vec3]
    free_points: Set[PointID]
    free_points_order: List[PointID] = field(init=False)

    def __post_init__(self) -> None:
        """
        Initialize consistent ordering for free points.
        """
        self.free_points_order = sorted(list(self.free_points))

    @property
    def fixed_points(self) -> Set[PointID]:
        """
        Points that are fixed (not free to move).
        """
        return set(self.positions.keys()) - self.free_points

    def get_free_array(self) -> np.ndarray:
        """
        Convert free points to flat array for solver.
        """
        positions = [self.positions[pid] for pid in self.free_points_order]
        return np.concatenate(positions)

    def update_from_array(self, array: np.ndarray) -> None:
        """
        Update free points from solver array in-place.

        This modifies the state directly for performance.
        """
        n_points = len(self.free_points_order)
        if array.shape != (n_points * 3,):
            raise ValueError(
                f"Array shape {array.shape} doesn't match expected ({n_points * 3},)"
            )

        positions_2d = array.reshape(n_points, 3)
        for i, point_id in enumerate(self.free_points_order):
            # Direct assignment without copy - caller owns the data
            self.positions[point_id] = positions_2d[i]

    def update_positions(self, new_positions: dict[PointID, Vec3]) -> None:
        """
        Replace positions dictionary in-place.

        This modifies the state directly for performance.
        """
        self.positions = new_positions

    def copy(self) -> "SuspensionState":
        """
        Create a deep copy.
        """
        return SuspensionState(
            positions={pid: pos.copy() for pid, pos in self.positions.items()},
            free_points=self.free_points.copy(),
        )

    def get(self, point_id: PointID) -> Vec3:
        """
        Get position of a specific point.
        """
        return self.positions[point_id]

    def set(self, point_id: PointID, position: Vec3) -> None:
        """
        Set position of a specific point.
        """
        self.positions[point_id] = position.copy()

    def __getitem__(self, point_id: PointID) -> Vec3:
        """
        Allow dict-like access.
        """
        return self.positions[point_id]

    def __setitem__(self, point_id: PointID, position: Vec3) -> None:
        """
        Allow dict-like assignment.
        """
        self.positions[point_id] = position.copy()

    def __contains__(self, point_id: PointID) -> bool:
        """
        Check if point exists.
        """
        return point_id in self.positions

    def items(self):
        """
        Iterate over (point_id, position) pairs.
        """
        return self.positions.items()

    def keys(self):
        """
        Iterate over point IDs.
        """
        return self.positions.keys()

    def values(self):
        """
        Iterate over positions.
        """
        return self.positions.values()
</file>

<file path="tests/test_constraints.py">
import numpy as np
import pytest

from kinematics.constraints import AngleConstraint, DistanceConstraint
from kinematics.enums import PointID


@pytest.fixture
def positions():
    return {
        PointID.LOWER_WISHBONE_INBOARD_FRONT: np.array([0.0, 0.0, 0.0]),
        PointID.LOWER_WISHBONE_INBOARD_REAR: np.array([1.0, 0.0, 0.0]),
        PointID.LOWER_WISHBONE_OUTBOARD: np.array([0.5, 1.0, 0.0]),
        PointID.UPPER_WISHBONE_INBOARD_FRONT: np.array([0.0, 0.0, 1.0]),
        PointID.UPPER_WISHBONE_OUTBOARD: np.array([0.5, 1.0, 1.0]),
    }


def test_distance_constraint(positions):
    target_distance = float(
        np.linalg.norm(
            positions[PointID.LOWER_WISHBONE_INBOARD_FRONT]
            - positions[PointID.LOWER_WISHBONE_OUTBOARD]
        )
    )

    constraint = DistanceConstraint(
        PointID.LOWER_WISHBONE_INBOARD_FRONT,
        PointID.LOWER_WISHBONE_OUTBOARD,
        target_distance,
    )

    # Test that constraint is satisfied at initial positions
    assert abs(constraint.residual(positions)) < 1e-10

    # Test that constraint detects violations
    modified_positions = positions.copy()
    modified_positions[PointID.LOWER_WISHBONE_OUTBOARD] += np.array([1.0, 0.0, 0.0])

    residual = constraint.residual(modified_positions)
    assert abs(residual) > 0.1  # Should be approximately 1.0


def test_angle_constraint():
    positions = {
        PointID.LOWER_WISHBONE_INBOARD_FRONT: np.array([0.0, 0.0, 0.0]),
        PointID.LOWER_WISHBONE_OUTBOARD: np.array([1.0, 0.0, 0.0]),
        PointID.UPPER_WISHBONE_INBOARD_FRONT: np.array([0.0, 0.0, 0.0]),
        PointID.UPPER_WISHBONE_OUTBOARD: np.array([0.0, 1.0, 0.0]),
    }

    constraint = AngleConstraint(
        v1_start=PointID.LOWER_WISHBONE_INBOARD_FRONT,
        v1_end=PointID.LOWER_WISHBONE_OUTBOARD,
        v2_start=PointID.UPPER_WISHBONE_INBOARD_FRONT,
        v2_end=PointID.UPPER_WISHBONE_OUTBOARD,
        target_angle=np.pi / 2,  # 90 degrees
    )

    # Should be satisfied at right angle
    assert abs(constraint.residual(positions)) < 1e-10
</file>

<file path="tests/test_targets.py">
import numpy as np
import pytest

from kinematics.enums import Axis
from kinematics.targets import resolve_target
from kinematics.types import PointTargetAxis, PointTargetVector, WorldAxisSystem


def test_resolve_axis_targets_returns_unit_axes():
    np.testing.assert_allclose(
        resolve_target(PointTargetAxis(Axis.X)), WorldAxisSystem.X
    )
    np.testing.assert_allclose(
        resolve_target(PointTargetAxis(Axis.Y)), WorldAxisSystem.Y
    )
    np.testing.assert_allclose(
        resolve_target(PointTargetAxis(Axis.Z)), WorldAxisSystem.Z
    )


def test_resolve_vector_target_normalizes():
    direction = resolve_target(PointTargetVector(np.array([10.0, 0.0, 0.0])))

    np.testing.assert_allclose(direction, WorldAxisSystem.X)
    assert np.isclose(np.linalg.norm(direction), 1.0)


def test_resolve_vector_target_zero_raises():
    with pytest.raises(ValueError):
        resolve_target(PointTargetVector(np.array([0.0, 0.0, 0.0])))
</file>

<file path="src/kinematics/vector_utils/geometric.py">
"""
Geometric computation utilities.

This module provides functions for computing geometric relationships between points and
vectors, including distances, midpoints, and angles. These utilities are fundamental to
kinematic analysis and constraint evaluation.
"""

import numpy as np

from kinematics.types import Vec3, make_vec3
from kinematics.vector_utils.generic import normalize_vector


def compute_point_point_distance(p1: Vec3, p2: Vec3) -> float:
    """
    Compute the Euclidean distance between two points.

    Args:
        p1: First point in 3D space.
        p2: Second point in 3D space.

    Returns:
        The Euclidean distance between the two points.
    """
    return float(np.linalg.norm(p1 - p2))


def compute_point_point_midpoint(p1: Vec3, p2: Vec3) -> Vec3:
    """
    Compute the midpoint between two points.

    Args:
        p1: First point in 3D space.
        p2: Second point in 3D space.

    Returns:
        The midpoint vector between the two points.
    """
    return make_vec3((p1 + p2) / 2)


def compute_vector_vector_angle(v1: Vec3, v2: Vec3) -> float:
    """
    Compute the angle between two vectors in radians.

    The vectors are automatically normalized before computing the angle,
    so input vectors do not need to be unit length.

    Args:
        v1: First vector in 3D space.
        v2: Second vector in 3D space.

    Returns:
        The angle between the vectors in radians (0 to ).

    Raises:
        ValueError: If either input vector has zero length.
    """
    v1_norm = normalize_vector(v1)
    v2_norm = normalize_vector(v2)
    return float(np.arccos(np.clip(np.dot(v1_norm, v2_norm), -1.0, 1.0)))
</file>

<file path="src/kinematics/constants.py">
# Used for equality checks to avoid floating point issues.
EPSILON = 1e-5

# Solve tolerances.
SOLVE_TOLERANCE_VALUE = 1e-4
SOLVE_TOLERANCE_STEP = 1e-7
SOLVE_TOLERANCE_GRAD = 1e-7

# Tolerance for tests; has headroom over solve tolerances.
TEST_TOLERANCE = 1e-3
</file>

<file path="tests/test_absolute_mode.py">
import numpy as np

from kinematics.enums import Axis, PointID, TargetPositionMode
from kinematics.points.derived.manager import DerivedPointsManager, DerivedPointsSpec
from kinematics.solver import resolve_targets_to_absolute, solve_sweep
from kinematics.state import SuspensionState
from kinematics.types import PointTarget, PointTargetAxis, SweepConfig


def test_resolve_targets_to_absolute():
    initial_positions = {
        PointID.WHEEL_CENTER: np.array([0.0, 0.0, 150.0]),
    }
    initial_state = SuspensionState(positions=initial_positions, free_points=set())

    # Relative conversion -> absolute
    relative_target = PointTarget(
        PointID.WHEEL_CENTER,
        PointTargetAxis(Axis.Z),
        50.0,
        TargetPositionMode.RELATIVE,
    )

    resolved = resolve_targets_to_absolute([relative_target], initial_state)

    assert resolved[0].mode == TargetPositionMode.ABSOLUTE
    assert resolved[0].value == 200.0  # 150 + 50

    # Absolute passthrough
    absolute_target = PointTarget(
        PointID.WHEEL_CENTER,
        PointTargetAxis(Axis.Z),
        400.0,
        TargetPositionMode.ABSOLUTE,
    )

    resolved2 = resolve_targets_to_absolute([absolute_target], initial_state)

    assert resolved2[0].mode == TargetPositionMode.ABSOLUTE
    assert resolved2[0].value == 400.0


def test_default_relative_mode():
    target = PointTarget(PointID.WHEEL_CENTER, PointTargetAxis(Axis.Z), 50)
    assert target.mode == TargetPositionMode.RELATIVE


def test_absolute_mode_solve():
    # No derived points
    derived_manager = DerivedPointsManager(DerivedPointsSpec({}, {}))

    positions = {PointID.LOWER_WISHBONE_OUTBOARD: np.array([0.0, 0.0, 0.0])}
    free = {PointID.LOWER_WISHBONE_OUTBOARD}
    initial_state = SuspensionState(positions=positions, free_points=free)

    # Fully determined with 3 absolute targets (X, Y, Z) applied simultaneously.
    x_sweep = [
        PointTarget(
            PointID.LOWER_WISHBONE_OUTBOARD,
            PointTargetAxis(Axis.X),
            10.0,
            TargetPositionMode.ABSOLUTE,
        )
    ]
    y_sweep = [
        PointTarget(
            PointID.LOWER_WISHBONE_OUTBOARD,
            PointTargetAxis(Axis.Y),
            -5.0,
            TargetPositionMode.ABSOLUTE,
        )
    ]
    z_sweep = [
        PointTarget(
            PointID.LOWER_WISHBONE_OUTBOARD,
            PointTargetAxis(Axis.Z),
            100.0,
            TargetPositionMode.ABSOLUTE,
        )
    ]

    states = solve_sweep(
        initial_state=initial_state,
        constraints=[],
        sweep_config=SweepConfig([x_sweep, y_sweep, z_sweep]),
        derived_manager=derived_manager,
    )

    assert len(states) == 1
    assert np.allclose(
        states[0].positions[PointID.LOWER_WISHBONE_OUTBOARD],
        np.array([10.0, -5.0, 100.0]),
    )
</file>

<file path="tests/test_loader.py">
from pathlib import Path

import pytest
import yaml

from kinematics.loader import LoadedSuspension, load_geometry
from kinematics.suspensions.core.geometry import SuspensionGeometry


@pytest.fixture
def empty_geometry_file(tmp_path: Path):
    empty_file = tmp_path / "empty_geometry.yaml"
    empty_file.touch()
    return empty_file


@pytest.fixture
def invalid_yaml_geometry_file(tmp_path: Path):
    file_path = tmp_path / "invalid_geometry.yaml"
    file_path.write_text('""')
    return file_path


@pytest.fixture
def invalid_geometry_file(tmp_path: Path):
    data = {
        "type": "DOUBLE_WISHBONE",
        "invalid_attribute": "value",
    }  # Valid type but invalid geometry
    file_path = tmp_path / "invalid_geometry.yaml"
    with open(file_path, "w") as f:
        yaml.dump(data, f)
    return file_path


def test_load_geometry_valid(double_wishbone_geometry_file):
    loaded = load_geometry(double_wishbone_geometry_file)
    assert isinstance(loaded, LoadedSuspension)
    assert isinstance(loaded.geometry, SuspensionGeometry)
    assert loaded.provider_cls is not None


def test_load_geometry_empty(empty_geometry_file):
    with pytest.raises(ValueError, match="Geometry file is empty"):
        load_geometry(empty_geometry_file)


def test_load_geometry_not_found(tmp_path: Path):
    with pytest.raises(FileNotFoundError, match="Geometry file not found"):
        load_geometry(tmp_path / "file_not_found.yaml")


def test_load_geometry_invalid(invalid_geometry_file):
    with pytest.raises(ValueError, match="Error validating geometry"):
        load_geometry(invalid_geometry_file)


def test_load_geometry_unsupported_type(tmp_path: Path):
    """
    Test handling of unsupported geometry types.
    """
    data = {"type": "UNSUPPORTED_TYPE", "name": "test"}
    file_path = tmp_path / "unsupported.yaml"
    with open(file_path, "w") as f:
        yaml.dump(data, f)

    with pytest.raises(ValueError, match="Unsupported geometry type"):
        load_geometry(file_path)


def test_load_geometry_missing_type(tmp_path: Path):
    """
    Test handling of missing geometry type.
    """
    data = {"name": "test"}  # Missing 'type' field
    file_path = tmp_path / "missing_type.yaml"
    with open(file_path, "w") as f:
        yaml.dump(data, f)

    with pytest.raises(ValueError, match="Geometry type not specified"):
        load_geometry(file_path)


def test_load_geometry_yaml_error(tmp_path: Path):
    """
    Test handling of malformed YAML.
    """
    file_path = tmp_path / "malformed.yaml"
    file_path.write_text("invalid: yaml: content: [")

    with pytest.raises(ValueError, match="Error parsing geometry file"):
        load_geometry(file_path)
</file>

<file path="tests/test_solver.py">
import numpy as np
import pytest

from kinematics.constants import TEST_TOLERANCE
from kinematics.constraints import DistanceConstraint
from kinematics.enums import Axis, PointID, TargetPositionMode
from kinematics.points.derived.manager import DerivedPointsManager, DerivedPointsSpec
from kinematics.solver import PointTarget, SolverConfig, solve_sweep
from kinematics.state import SuspensionState
from kinematics.types import PointTargetAxis, SweepConfig


@pytest.fixture
def simple_positions():
    positions_dict = {
        PointID.LOWER_WISHBONE_INBOARD_FRONT: np.array([-1.0, 0.0, 0.0]),
        PointID.LOWER_WISHBONE_INBOARD_REAR: np.array([1.0, 0.0, 0.0]),
        PointID.LOWER_WISHBONE_OUTBOARD: np.array([0.0, 1.0, 0.0]),
    }
    return positions_dict


@pytest.fixture
def length_forward_leg(simple_positions):
    x_forward_leg = np.linalg.norm(
        simple_positions[PointID.LOWER_WISHBONE_INBOARD_FRONT]
        - simple_positions[PointID.LOWER_WISHBONE_OUTBOARD],
    )
    return x_forward_leg


@pytest.fixture
def length_rearward_leg(simple_positions):
    x_rearward_leg = np.linalg.norm(
        simple_positions[PointID.LOWER_WISHBONE_INBOARD_REAR]
        - simple_positions[PointID.LOWER_WISHBONE_OUTBOARD]
    )
    return x_rearward_leg


@pytest.fixture
def simple_constraints(simple_positions, length_forward_leg, length_rearward_leg):
    return [
        DistanceConstraint(
            p1=PointID.LOWER_WISHBONE_INBOARD_FRONT,
            p2=PointID.LOWER_WISHBONE_OUTBOARD,
            target_distance=length_forward_leg,
        ),
        DistanceConstraint(
            p1=PointID.LOWER_WISHBONE_INBOARD_REAR,
            p2=PointID.LOWER_WISHBONE_OUTBOARD,
            target_distance=length_rearward_leg,
        ),
    ]


@pytest.fixture
def simple_sweep_config():
    displacements = [0.0, 0.5, 1.0]
    point_targets = [
        PointTarget(
            point_id=PointID.LOWER_WISHBONE_OUTBOARD,
            direction=PointTargetAxis(Axis.Z),
            value=d,
            mode=TargetPositionMode.RELATIVE,
        )
        for d in displacements
    ]
    return SweepConfig([point_targets])


def make_noop_derived_manager():
    # No derived points -> empty spec
    spec = DerivedPointsSpec(functions={}, dependencies={})
    return DerivedPointsManager(spec)


def test_solve_sweep(
    simple_positions,
    simple_constraints,
    simple_sweep_config,
    length_forward_leg,
    length_rearward_leg,
):
    free_points = {PointID.LOWER_WISHBONE_OUTBOARD}

    # Create SuspensionState instead of separate positions and free_points
    initial_state = SuspensionState(positions=simple_positions, free_points=free_points)

    # Extract displacement values for assertions
    displacement_values = [
        target.value for target in simple_sweep_config.target_sweeps[0]
    ]

    states = solve_sweep(
        initial_state=initial_state,
        constraints=simple_constraints,
        sweep_config=simple_sweep_config,
        derived_manager=make_noop_derived_manager(),
        solver_config=SolverConfig(ftol=1e-6, xtol=1e-6, verbose=0),
    )

    assert len(states) == len(displacement_values)

    # Check each state maintains constraints
    for i, state in enumerate(states):
        p_front = state.positions[PointID.LOWER_WISHBONE_INBOARD_FRONT]
        p_rear = state.positions[PointID.LOWER_WISHBONE_INBOARD_REAR]
        p_outboard = state.positions[PointID.LOWER_WISHBONE_OUTBOARD]

        # Distance constraints
        assert np.linalg.norm(p_outboard - p_front) == pytest.approx(
            length_forward_leg, rel=TEST_TOLERANCE
        )
        assert np.linalg.norm(p_outboard - p_rear) == pytest.approx(
            length_rearward_leg, rel=TEST_TOLERANCE
        )

        # Target displacement
        assert p_outboard[2] == pytest.approx(
            displacement_values[i], rel=TEST_TOLERANCE
        )
</file>

<file path="src/kinematics/visualization/main.py">
from dataclasses import dataclass

import numpy as np

from kinematics.enums import PointID
from kinematics.suspensions.implementations.double_wishbone import (
    DoubleWishboneGeometry,
)
from kinematics.types import Vec3


@dataclass
class LinkVisualization:
    points: list[PointID]
    color: str
    label: str
    linewidth: float = 3.0
    linestyle: str = "-"
    marker: str = "o"
    markersize: float = 10.0


@dataclass
class WheelVisualization:
    diameter: float
    width: float
    num_points: int = 50
    color: str = "black"
    alpha: float = 0.75
    linestyle: str = "-"


class SuspensionVisualizer:
    def __init__(
        self, geometry: DoubleWishboneGeometry, wheel_config: WheelVisualization
    ):
        self.geometry = geometry
        self.wheel_config = wheel_config
        self.links = self.define_links()

    def define_links(self) -> list[LinkVisualization]:
        return [
            LinkVisualization(
                points=[
                    PointID.UPPER_WISHBONE_INBOARD_FRONT,
                    PointID.UPPER_WISHBONE_OUTBOARD,
                    PointID.UPPER_WISHBONE_INBOARD_REAR,
                ],
                color="dodgerblue",
                label="Upper Wishbone",
            ),
            LinkVisualization(
                points=[
                    PointID.LOWER_WISHBONE_INBOARD_FRONT,
                    PointID.LOWER_WISHBONE_OUTBOARD,
                    PointID.LOWER_WISHBONE_INBOARD_REAR,
                ],
                color="dodgerblue",
                label="Lower Wishbone",
            ),
            LinkVisualization(
                points=[
                    PointID.TRACKROD_OUTBOARD,
                    PointID.UPPER_WISHBONE_OUTBOARD,
                    PointID.LOWER_WISHBONE_OUTBOARD,
                    PointID.TRACKROD_OUTBOARD,
                ],
                color="slategrey",
                label="Upright",
            ),
            LinkVisualization(
                points=[PointID.TRACKROD_INBOARD, PointID.TRACKROD_OUTBOARD],
                color="darkorange",
                label="Track Rod",
            ),
            LinkVisualization(
                points=[PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD],
                color="forestgreen",
                label="Axle",
            ),
        ]

    def draw_wheel(
        self,
        ax,
        positions: dict[PointID, Vec3],
    ) -> None:
        wheel_center = positions[PointID.WHEEL_CENTER]
        wheel_inboard = positions[PointID.WHEEL_INBOARD]
        wheel_outboard = positions[PointID.WHEEL_OUTBOARD]
        axle_vector = positions[PointID.AXLE_OUTBOARD] - positions[PointID.AXLE_INBOARD]

        axle_vector = axle_vector / np.linalg.norm(axle_vector)

        e1 = axle_vector
        e2 = np.array([1, 0, 0])
        if np.abs(np.dot(e1, e2)) > 0.9:
            e2 = np.array([0, 1, 0])
        e2 = e2 - np.dot(e2, e1) * e1
        e2 = e2 / np.linalg.norm(e2)

        e3 = np.cross(e1, e2)

        theta = np.linspace(0, 2 * np.pi, self.wheel_config.num_points)
        radius = self.wheel_config.diameter / 2

        rim_points_center = np.zeros((self.wheel_config.num_points, 3))
        rim_points_inboard = np.zeros((self.wheel_config.num_points, 3))
        rim_points_outboard = np.zeros((self.wheel_config.num_points, 3))

        for i, angle in enumerate(theta):
            rim_points_center[i] = wheel_center + radius * (
                np.cos(angle) * e2 + np.sin(angle) * e3
            )
            rim_points_inboard[i] = wheel_inboard + radius * (
                np.cos(angle) * e2 + np.sin(angle) * e3
            )
            rim_points_outboard[i] = wheel_outboard + radius * (
                np.cos(angle) * e2 + np.sin(angle) * e3
            )

        ax.plot(
            rim_points_center[:, 0],
            rim_points_center[:, 1],
            rim_points_center[:, 2],
            color=self.wheel_config.color,
            alpha=0.25,
            linestyle=self.wheel_config.linestyle,
        )

        ax.plot(
            rim_points_inboard[:, 0],
            rim_points_inboard[:, 1],
            rim_points_inboard[:, 2],
            color=self.wheel_config.color,
            alpha=self.wheel_config.alpha,
            linestyle=self.wheel_config.linestyle,
        )

        ax.plot(
            rim_points_outboard[:, 0],
            rim_points_outboard[:, 1],
            rim_points_outboard[:, 2],
            color=self.wheel_config.color,
            alpha=self.wheel_config.alpha,
            linestyle=self.wheel_config.linestyle,
        )

        spoke_indices = np.linspace(0, self.wheel_config.num_points - 1, 12, dtype=int)

        for idx in spoke_indices:
            ax.plot(
                [rim_points_inboard[idx, 0], rim_points_outboard[idx, 0]],
                [rim_points_inboard[idx, 1], rim_points_outboard[idx, 1]],
                [rim_points_inboard[idx, 2], rim_points_outboard[idx, 2]],
                color=self.wheel_config.color,
                alpha=self.wheel_config.alpha,
                linestyle=self.wheel_config.linestyle,
            )
</file>

<file path="tests/points/test_derived.py">
from functools import partial

import numpy as np
import pytest

from kinematics.enums import PointID
from kinematics.points.derived.definitions import (
    get_axle_midpoint,
    get_wheel_center,
    get_wheel_inboard,
    get_wheel_outboard,
)
from kinematics.points.derived.manager import DerivedPointsManager, DerivedPointsSpec


@pytest.fixture
def sample_positions():
    # Set up a simple configuration:
    # - Axle inboard at origin
    # - Axle outboard at x=2
    # - This makes the axle 2 units wide pointing along x-axis
    return {
        PointID.AXLE_INBOARD: np.array([0.0, 0.0, 0.0]),
        PointID.AXLE_OUTBOARD: np.array([2.0, 0.0, 0.0]),
    }


def test_axle_midpoint(sample_positions):
    result = get_axle_midpoint(sample_positions)
    np.testing.assert_array_equal(result, np.array([1.0, 0.0, 0.0]))


def test_wheel_center(sample_positions):
    # With axle outboard at x=2.0 and offset of 0.5, wheel center should be at x=2.5
    result = get_wheel_center(sample_positions, wheel_offset=0.5)
    np.testing.assert_array_equal(result, np.array([2.5, 0.0, 0.0]))


def test_wheel_inboard_outboard(sample_positions):
    # First compute wheel center
    wheel_center = get_wheel_center(sample_positions, wheel_offset=0.5)
    positions_dict = sample_positions.copy()
    positions_dict[PointID.WHEEL_CENTER] = wheel_center

    # Test inboard point (should be 0.5 units inboard of wheel center)
    inboard = get_wheel_inboard(positions_dict, wheel_width=1.0)
    np.testing.assert_array_equal(inboard, np.array([2.0, 0.0, 0.0]))

    # Test outboard point (should be 0.5 units outboard of wheel center)
    outboard = get_wheel_outboard(positions_dict, wheel_width=1.0)
    np.testing.assert_array_equal(outboard, np.array([3.0, 0.0, 0.0]))


def test_dependency_manager_basic(sample_positions):
    """
    Test that the DerivedPointsManager can calculate axle midpoint.
    """
    functions = {
        PointID.AXLE_MIDPOINT: get_axle_midpoint,
    }
    dependencies = {
        PointID.AXLE_MIDPOINT: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
    }
    spec = DerivedPointsSpec(functions=functions, dependencies=dependencies)
    manager = DerivedPointsManager(spec)

    manager.update_in_place(sample_positions)

    # Should have original positions plus the derived point
    assert len(sample_positions) == 3
    assert PointID.AXLE_MIDPOINT in sample_positions
    np.testing.assert_array_equal(
        sample_positions[PointID.AXLE_MIDPOINT], np.array([1.0, 0.0, 0.0])
    )


def test_dependency_manager_complex(sample_positions):
    """
    Test that the DerivedPointsManager can handle dependencies between derived points.
    """
    functions = {
        PointID.AXLE_MIDPOINT: get_axle_midpoint,
        PointID.WHEEL_CENTER: partial(get_wheel_center, wheel_offset=0.5),
        PointID.WHEEL_INBOARD: partial(get_wheel_inboard, wheel_width=1.0),
        PointID.WHEEL_OUTBOARD: partial(get_wheel_outboard, wheel_width=1.0),
    }
    dependencies = {
        PointID.AXLE_MIDPOINT: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
        PointID.WHEEL_CENTER: {PointID.AXLE_INBOARD, PointID.AXLE_OUTBOARD},
        PointID.WHEEL_INBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
        PointID.WHEEL_OUTBOARD: {PointID.WHEEL_CENTER, PointID.AXLE_INBOARD},
    }
    spec = DerivedPointsSpec(functions=functions, dependencies=dependencies)
    manager = DerivedPointsManager(spec)

    manager.update_in_place(sample_positions)

    # Should have original positions plus all derived points
    assert len(sample_positions) == 6
    assert PointID.AXLE_MIDPOINT in sample_positions
    assert PointID.WHEEL_CENTER in sample_positions
    assert PointID.WHEEL_INBOARD in sample_positions
    assert PointID.WHEEL_OUTBOARD in sample_positions

    # Check values
    np.testing.assert_array_equal(
        sample_positions[PointID.AXLE_MIDPOINT], np.array([1.0, 0.0, 0.0])
    )
    np.testing.assert_array_equal(
        sample_positions[PointID.WHEEL_CENTER], np.array([2.5, 0.0, 0.0])
    )
    np.testing.assert_array_equal(
        sample_positions[PointID.WHEEL_INBOARD], np.array([2.0, 0.0, 0.0])
    )
    np.testing.assert_array_equal(
        sample_positions[PointID.WHEEL_OUTBOARD], np.array([3.0, 0.0, 0.0])
    )


def test_circular_dependency_detection():
    """
    Test that circular dependencies are detected.
    """

    def dummy_func(positions):
        return positions[PointID.AXLE_INBOARD]

    functions = {
        PointID.WHEEL_CENTER: dummy_func,
        PointID.WHEEL_OUTBOARD: dummy_func,
    }
    dependencies = {
        PointID.WHEEL_CENTER: {PointID.WHEEL_OUTBOARD},
        PointID.WHEEL_OUTBOARD: {PointID.WHEEL_CENTER},
    }

    spec = DerivedPointsSpec(functions=functions, dependencies=dependencies)

    with pytest.raises(ValueError, match="Circular dependency detected"):
        DerivedPointsManager(spec)
</file>

<file path="pyproject.toml">
[project]
name = "kinematics"
version = "0.1.0"
description = "Kinematics solver for suspension systems."
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "marshmallow-dataclass>=8.7.1",
    "numpy>=2.2.0",
    "python-dotenv>=1.0.1",
    "pyyaml>=6.0.2",
    "scipy>=1.14.1",
    "typer>=0.19.2",
]

[project.optional-dependencies]
viz = ["matplotlib>=3.8"]
cli = ["typer>=0.12"]

[dependency-groups]
dev = [
    "docformatter>=1.7.7",
    "pytest>=8.3.4",
    "ruff>=0.13.3",
    "ty>=0.0.1a21",
]

[tool.docformatter]
recursive = true
wrap-summaries = 88
wrap-descriptions = 88
pre-summary-newline = true
close-quotes-on-newline = true
blank = false
make-summary-multi-line = true


# [tool.uv.workspace]
# members = ["src/kinematics"]

# [tool.hatchling.build.targets.wheel]
# packages = ["src/kinematics"]
</file>

<file path="src/kinematics/points/derived/definitions.py">
"""
Common derived point calculation functions.

These functions calculate positions of derived points based on the positions of other
points in the suspension system. They are shared across different suspension types to
avoid code duplication.
"""

import numpy as np

from kinematics.enums import PointID
from kinematics.types import Vec3
from kinematics.vector_utils.generic import normalize_vector


def get_axle_midpoint(positions: dict[PointID, Vec3]) -> np.ndarray:
    """
    Calculates the midpoint of the axle.
    """
    p1 = positions[PointID.AXLE_INBOARD]
    p2 = positions[PointID.AXLE_OUTBOARD]
    return (p1 + p2) / 2


def get_wheel_center(positions: dict[PointID, Vec3], wheel_offset: float) -> np.ndarray:
    """
    Calculates the wheel center point, offset from the axle outboard face.
    """
    p1 = positions[PointID.AXLE_OUTBOARD]
    p2 = positions[PointID.AXLE_INBOARD]
    v = p1 - p2  # Vector pointing outboard
    v = normalize_vector(v)
    return p1 + v * wheel_offset


def get_wheel_inboard(positions: dict[PointID, Vec3], wheel_width: float) -> np.ndarray:
    """
    Calculates the inboard lip of the wheel.
    """
    p1 = positions[PointID.AXLE_INBOARD]
    p2 = positions[PointID.WHEEL_CENTER]
    v = p2 - p1  # Vector from axle inboard to wheel center
    v = normalize_vector(v)
    return p2 - v * (wheel_width / 2)


def get_wheel_outboard(
    positions: dict[PointID, Vec3], wheel_width: float
) -> np.ndarray:
    """
    Calculates the outboard lip of the wheel.
    """
    p1 = positions[PointID.WHEEL_CENTER]
    p2 = positions[PointID.AXLE_INBOARD]
    v = p1 - p2  # Vector from axle inboard to wheel center
    v = normalize_vector(v)
    return p1 + v * (wheel_width / 2)
</file>

<file path="src/kinematics/visualization/debug.py">
from pathlib import Path

import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np

from kinematics.enums import PointID
from kinematics.types import Vec3
from kinematics.visualization.main import SuspensionVisualizer


def create_animation(
    position_states: list[dict[PointID, Vec3]],
    initial_positions: dict[PointID, Vec3],
    visualizer: SuspensionVisualizer,
    output_path: Path,
    fps: int = 20,
    interval: int = 200,
) -> None:
    fig_scalar = 1.25
    fig = plt.figure(figsize=(16 * fig_scalar, 10 * fig_scalar))
    gs = fig.add_gridspec(2, 2)

    axes = {
        "front": fig.add_subplot(gs[0, 0], projection="3d"),
        "top": fig.add_subplot(gs[1, 0], projection="3d"),
        "side": fig.add_subplot(gs[0, 1], projection="3d"),
        "iso": fig.add_subplot(gs[1, 1], projection="3d"),
    }

    all_points = []
    for positions in position_states:
        all_points.extend([pos for pos in positions.values()])

    all_points = np.array(all_points)
    min_bounds = all_points.min(axis=0) - 100
    max_bounds = all_points.max(axis=0) + 100

    def update(frame: int) -> None:
        positions = position_states[frame]

        for view_name, ax in axes.items():
            ax.clear()

            if view_name == "top":
                ax.view_init(elev=90, azim=0)
                ax.set_title("Top View [X-Y]")
                ax.set_proj_type("ortho")
                ax.set_zticklabels([])  # type: ignore
            elif view_name == "front":
                ax.view_init(elev=0, azim=0)
                ax.set_title("Front View [Y-Z]")
                ax.set_proj_type("ortho")
                ax.set_xticklabels([])
            elif view_name == "side":
                ax.view_init(elev=0, azim=90)
                ax.set_title("Side View [X-Z]")
                ax.set_proj_type("ortho")
                ax.set_yticklabels([])
            else:
                ax.view_init(elev=20, azim=45)
                ax.set_title("Isometric View")
                ax.set_proj_type("ortho")

            for link in visualizer.links:
                points = np.array([positions[point_id] for point_id in link.points])
                ax.plot(
                    points[:, 0],
                    points[:, 1],
                    points[:, 2],
                    color=link.color,
                    linewidth=link.linewidth,
                    linestyle=link.linestyle,
                    marker=link.marker,
                    markersize=link.markersize,
                    label=link.label if view_name == "iso" else None,
                )

            visualizer.draw_wheel(ax, positions)

            x_mid = (max_bounds[0] + min_bounds[0]) * 0.5
            y_mid = (max_bounds[1] + min_bounds[1]) * 0.5
            z_mid = (max_bounds[2] + min_bounds[2]) * 0.5

            max_range = max(
                max_bounds[0] - min_bounds[0],
                max_bounds[1] - min_bounds[1],
                max_bounds[2] - min_bounds[2],
            )

            ax.set_xlim3d([x_mid - max_range / 2, x_mid + max_range / 2])
            ax.set_ylim3d([y_mid - max_range / 2, y_mid + max_range / 2])
            ax.set_zlim3d([z_mid - max_range / 2, z_mid + max_range / 2])

            ax.set_box_aspect([1, 1, 1])

            ax.set_xlabel("X [mm]")
            ax.set_ylabel("Y [mm]")
            ax.set_zlabel("Z [mm]")

            if view_name == "iso":
                ax.legend(loc="upper left")

        title_string = (
            f"Wheel Center Z: {positions[PointID.WHEEL_CENTER][2] - initial_positions[PointID.WHEEL_CENTER][2]:.1f} [mm]",
            f"Rack Displacement: {positions[PointID.TRACKROD_INBOARD][1] - initial_positions[PointID.TRACKROD_INBOARD][1]:.1f} [mm]",
        )
        fig.suptitle(
            "\n".join(title_string),
            fontsize=16,
        )

    plt.subplots_adjust(
        left=0.0,
        right=1,
        bottom=0.025,
        top=0.95,
        wspace=0.01,
        hspace=0.01,
    )
    anim = animation.FuncAnimation(
        fig,
        update,  # type: ignore
        frames=len(position_states),
        interval=interval,
        blit=False,
    )

    anim.save(output_path, writer="pillow", fps=fps)
    plt.close()
</file>

<file path="src/kinematics/cli.py">
from pathlib import Path

import typer

from kinematics.enums import Axis, PointID
from kinematics.loader import load_geometry
from kinematics.main import solve_suspension_sweep
from kinematics.solver import PointTarget
from kinematics.types import PointTargetAxis, SweepConfig

app = typer.Typer(add_completion=False)


@app.command()
def solve(
    geometry: Path,
    steps: int = typer.Option(1, help="Number of sweep steps"),
):
    loaded = load_geometry(geometry)

    # We should actually define a sweep file format for this to be any use,
    # but for now just do a simple Z bump sweep on the wheel center.
    targets = [
        PointTarget(
            point_id=PointID.WHEEL_CENTER,
            direction=PointTargetAxis(Axis.Z),
            value=0.01 * i,
        )
        for i in range(steps)
    ]
    sweep_config = SweepConfig([targets])

    solution = solve_suspension_sweep(
        loaded.geometry, loaded.provider_cls, sweep_config
    )
    typer.echo(f"converged=True steps={len(solution)}")


if __name__ == "__main__":
    app()
</file>

<file path="src/kinematics/loader.py">
"""
YAML geometry loader with validation.

This module handles file I/O, schema parsing, and geometry validation for all suspension
types.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Type, cast

import yaml
from marshmallow.exceptions import ValidationError
from marshmallow_dataclass import class_schema

from kinematics.suspensions.core.provider import SuspensionProvider
from kinematics.suspensions.registry import build_registry

if TYPE_CHECKING:
    from kinematics.suspensions.core.geometry import SuspensionGeometry


@dataclass
class LoadedSuspension:
    """
    Result of loading a suspension geometry from a file.

    Attributes:
        geometry: The loaded and validated suspension geometry instance
        provider_cls: The provider class that can instantiate solvers for this geometry
    """

    geometry: SuspensionGeometry
    provider_cls: Type[SuspensionProvider]


def load_geometry(file_path: Path) -> LoadedSuspension:
    """
    Load suspension geometry from a YAML file.

    Args:
        file_path: Path to the YAML geometry file.

    Returns:
        LoadedSuspension dataclass containing the geometry and provider class.

    Raises:
        FileNotFoundError: If the file doesn't exist.
        ValueError: If the file contents are invalid or geometry type is unsupported.
        OSError: For general file handling errors.
    """
    if not file_path.exists():
        raise FileNotFoundError(f"Geometry file not found: {file_path}")

    try:
        with open(file_path, "r") as f:
            yaml_data = yaml.safe_load(f)

        if yaml_data is None:
            raise ValueError("Geometry file is empty.")

        if "type" not in yaml_data:
            raise ValueError("Geometry type not specified in file")

        geometry_type_key = yaml_data.pop("type")
        registry = build_registry()
        if geometry_type_key not in registry:
            raise ValueError(f"Unsupported geometry type: {geometry_type_key}")

        # Get model and provider classes from registry.
        model_class, provider_class = registry[geometry_type_key]

        # Create schema for the model and load the data.
        GeometrySchema = class_schema(model_class)
        geometry = cast("SuspensionGeometry", GeometrySchema().load(yaml_data))

        try:
            if not geometry.validate():
                raise ValueError("Geometry validation failed.")
        except AttributeError:
            # Geometry object doesn't have validate method, assume it's valid.
            pass

        return LoadedSuspension(geometry=geometry, provider_cls=provider_class)

    except yaml.YAMLError as e:
        raise ValueError(f"Error parsing geometry file: {e}") from e
    except ValidationError as e:
        raise ValueError(f"Error validating geometry: {e}") from e
    except (IOError, OSError) as e:
        raise OSError(f"Error reading geometry file: {e}") from e
</file>

<file path="src/kinematics/targets.py">
"""
Target resolution utilities for suspension kinematics.

This module provides functions to resolve target directions into world coordinate
vectors.
"""

from kinematics.enums import Axis
from kinematics.types import (
    PointTargetAxis,
    PointTargetDirection,
    PointTargetVector,
    Vec3,
    WorldAxisSystem,
)
from kinematics.vector_utils.generic import normalize_vector


def resolve_target(target: PointTargetDirection) -> Vec3:
    """
    Resolves a target direction specification into a unit vector in world coordinates.

    Handles both axis-based directions (X, Y, Z) and arbitrary vector directions,
    normalizing the result to ensure it's a unit vector.

    Args:
        target: The target direction specification to resolve.

    Returns:
        A unit vector in world coordinates representing the target direction.
    """
    if isinstance(target, PointTargetAxis):
        if target.axis is Axis.X:
            return WorldAxisSystem.X
        if target.axis is Axis.Y:
            return WorldAxisSystem.Y
        if target.axis is Axis.Z:
            return WorldAxisSystem.Z
        raise ValueError(f"Unsupported axis: {target.axis!r}")

    if isinstance(target, PointTargetVector):
        return normalize_vector(target.vector)

    raise TypeError(f"Unsupported target type: {type(target)!r}")
</file>

<file path="src/kinematics/types.py">
"""
Composite type definitions for suspension kinematics.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Annotated, Final, Literal, NamedTuple, Union

import numpy as np
from numpy.typing import NDArray

from kinematics.enums import Axis, PointID, TargetPositionMode

Vec3 = Annotated[NDArray[np.float64], Literal[3]]


def make_vec3(data) -> NDArray[np.float64]:
    """
    Creates a 3-element float64 numpy array from input data.

    Args:
        data: Input data convertible to a 3-element array.

    Returns:
        A 3-element numpy array with dtype float64.

    Raises:
        ValueError: If the input cannot be shaped into a 3-element array.
    """
    if isinstance(data, np.ndarray) and data.dtype == np.float64 and data.shape == (3,):
        return data

    arr = np.asarray(data, dtype=np.float64)
    if arr.shape != (3,):
        raise ValueError(f"Vec3 must have shape (3,), got {arr.shape}")
    return arr


class WorldAxisSystem:
    """
    World coordinate system unit axis vectors.

    Usage:
        WorldAxisSystem.X  # -> np.array([1.0, 0.0, 0.0])
        WorldAxisSystem.Y  # -> np.array([0.0, 1.0, 0.0])
        WorldAxisSystem.Z  # -> np.array([0.0, 0.0, 1.0])
    """

    X: Final[Vec3] = np.array([1.0, 0.0, 0.0], dtype=np.float64)
    Y: Final[Vec3] = np.array([0.0, 1.0, 0.0], dtype=np.float64)
    Z: Final[Vec3] = np.array([0.0, 0.0, 1.0], dtype=np.float64)


@dataclass
class SweepConfig:
    """
    Configuration for a parametric sweep over multiple target dimensions.

    Each inner list represents one sweep dimension (e.g., bump travel, steering angle).
    All dimensions must have the same length - the sweep will iterate through
    corresponding indices across all dimensions simultaneously.

    Example:
        bump_targets = [PointTarget(..., value=-30), ..., PointTarget(..., value=30)]
        steer_targets = [PointTarget(..., value=-10), ..., PointTarget(..., value=10)]
        config = SweepConfig([bump_targets, steer_targets])
    """

    target_sweeps: list[list["PointTarget"]]

    def __post_init__(self):
        if not self.target_sweeps:
            return

        lengths = [len(sweep) for sweep in self.target_sweeps]
        if len(set(lengths)) > 1:
            raise ValueError(
                f"All sweep dimensions must have the same length. Got: {lengths}"
            )

    @property
    def n_steps(self) -> int:
        """
        Number of steps in the sweep.
        """
        if not self.target_sweeps:
            return 0
        return len(self.target_sweeps[0])


class PointTarget(NamedTuple):
    """
    Defines a target constraint for a specific point during kinematic solving.

    The mode determines how the value is interpreted initially, but all targets
    are converted to absolute coordinates before solving begins.

    Attributes:
        point_id: The point to constrain
        direction: Direction along which to apply the target
        value: Target value (interpretation depends on mode)
        mode: Whether value is relative displacement or absolute coordinate
    """

    point_id: PointID
    direction: "PointTargetDirection"
    value: float
    mode: TargetPositionMode = TargetPositionMode.RELATIVE


@dataclass(slots=True, frozen=True)
class PointTargetAxis:
    """
    A target direction defined by one of the principal axes.

    Attributes:
        axis (Axis): The axis to use as the target direction.
    """

    axis: Axis


@dataclass(slots=True, frozen=True)
class PointTargetVector:
    """
    A target direction defined by an arbitrary vector.

    Attributes:
        vector (Vec3): The vector defining the target direction.
    """

    vector: Vec3


PointTargetDirection = Union[PointTargetAxis, PointTargetVector]
</file>

<file path="src/kinematics/points/derived/manager.py">
"""
Derived point specifications and management.
"""

from dataclasses import dataclass
from typing import Callable, Set

import numpy as np

from kinematics.enums import PointID
from kinematics.types import Vec3

# Function signature for computing a derived point position
PositionFn = Callable[[dict[PointID, Vec3]], np.ndarray]


@dataclass(frozen=True)
class DerivedPointsSpec:
    """
    Specification for derived point calculations.

    Contains the functions to compute derived points and their dependencies in a self-
    describing format that can be validated and sorted.
    """

    functions: dict[PointID, PositionFn]
    dependencies: dict[PointID, Set[PointID]]

    def all_points(self) -> Set[PointID]:
        """
        Get all derived point IDs defined in this spec.
        """
        return set(self.functions.keys())

    def validate(self) -> None:
        """
        Validate the spec for consistency.

        Raises:
            ValueError: If spec is inconsistent
        """
        # Check that all points in functions have dependencies defined
        function_points = set(self.functions.keys())
        dependency_points = set(self.dependencies.keys())

        if function_points != dependency_points:
            missing_deps = function_points - dependency_points
            extra_deps = dependency_points - function_points

            msg_parts = []
            if missing_deps:
                msg_parts.append(f"Missing dependencies for: {missing_deps}")
            if extra_deps:
                msg_parts.append(f"Extra dependencies for: {extra_deps}")

            raise ValueError("; ".join(msg_parts))

    def __post_init__(self):
        """
        Validate the spec after initialization.
        """
        self.validate()


class DerivedPointsManager:
    """
    Manages the calculation of derived points by building and resolving a dependency
    graph to ensure the correct update order.
    """

    def __init__(self, spec: DerivedPointsSpec):
        self.spec = spec
        self.dependency_graph = spec.dependencies

        # This will raise an error if cycles are detected.
        self.update_order = self.get_topological_sort()

    def detect_cycles_util(
        self, node: PointID, visited: set, recursion_stack: set
    ) -> bool:
        visited.add(node)
        recursion_stack.add(node)

        for neighbor in self.dependency_graph.get(node, set()):
            if neighbor not in visited:
                if self.detect_cycles_util(neighbor, visited, recursion_stack):
                    return True
            elif neighbor in recursion_stack:
                return True  # Cycle detected

        recursion_stack.remove(node)
        return False

    def get_topological_sort(self) -> list[PointID]:
        """
        Performs a topological sort of the derived points to determine the correct
        calculation order.

        Raises:
            ValueError: If a circular dependency is detected in the graph.
        """
        visited = set()
        recursion_stack = set()
        nodes = set(self.dependency_graph.keys())

        for node in nodes:
            if node not in visited:
                if self.detect_cycles_util(node, visited, recursion_stack):
                    raise ValueError(
                        "Circular dependency detected in derived point definitions."
                    )

        visited.clear()
        order = []

        def dfs(node: PointID):
            if node in visited:
                return
            visited.add(node)

            # Recurse on dependencies that are also derived points
            for dep in self.dependency_graph.get(node, set()):
                if dep in self.spec.functions:
                    dfs(dep)

            order.append(node)

        for point_id in self.spec.functions:
            if point_id not in visited:
                dfs(point_id)

        return order

    def update_in_place(self, positions: dict[PointID, Vec3]) -> None:
        """
        Compute derived points and add them to positions dict in-place.

        Args:
            positions: Dictionary to mutate in-place by adding derived points.
        """
        for point_id in self.update_order:
            update_func = self.spec.functions[point_id]
            positions[point_id] = update_func(positions)
</file>

<file path="src/kinematics/__init__.py">
from kinematics.constraints import Constraint
from kinematics.enums import PointID, TargetPositionMode
from kinematics.loader import load_geometry
from kinematics.solver import PointTarget, SolverConfig, solve, solve_sweep
from kinematics.types import SweepConfig

__all__ = [
    "load_geometry",
    "solve",
    "solve_sweep",
    "PointID",
    "PointTarget",
    "SweepConfig",
    "TargetPositionMode",
    "Constraint",
    "SolverConfig",
]
</file>

<file path="src/kinematics/constraints.py">
"""
Geometric constraints for kinematic systems.

This module defines constraint classes that enforce geometric relationships between
points in suspension kinematics, such as distances, angles, and positional constraints.
Each constraint computes a residual value that the solver attempts to drive to zero.
"""

from abc import ABC, abstractmethod
from typing import Set

import numpy as np

from kinematics.enums import Axis, PointID
from kinematics.types import Vec3, make_vec3
from kinematics.vector_utils.geometric import (
    compute_point_point_distance,
    compute_vector_vector_angle,
)


class Constraint(ABC):
    """
    Base class for all kinematics constraints.

    Constraints define geometric relationships that must be satisfied in the kinematic
    system. Each constraint computes a residual value representing the deviation from
    the desired condition. The solver minimizes these residuals to find valid
    configurations.
    """

    @property
    @abstractmethod
    def involved_points(self) -> Set[PointID]:
        """
        Returns a set of all PointIDs that this constraint operates on.
        """
        pass

    @abstractmethod
    def residual(self, positions: dict[PointID, Vec3]) -> float:
        """
        Calculate constraint residual.

        The solver's goal is to drive this value to zero. Returns a scalar float
        representing the constraint violation.
        """
        pass


class DistanceConstraint(Constraint):
    """
    Constrains the Euclidean distance between two points.

    This constraint enforces that the distance between two specified points remains
    constant at a target value, useful for rigid links or fixed separations in the
    suspension geometry.
    """

    def __init__(self, p1: PointID, p2: PointID, target_distance: float):
        """
        Initialize the distance constraint.

        Args:
            p1: First point identifier.
            p2: Second point identifier.
            target_distance: The required distance between the points.
        """
        self.p1 = p1
        self.p2 = p2
        self.target_distance = target_distance

    @property
    def involved_points(self) -> Set[PointID]:
        return {self.p1, self.p2}

    def residual(self, positions: dict[PointID, Vec3]) -> float:
        """
        Compute the distance residual.

        Returns the difference between the current distance and target distance.
        Positive values indicate the points are too far apart.
        """
        current_distance = compute_point_point_distance(
            positions[self.p1], positions[self.p2]
        )
        return float(current_distance - self.target_distance)


class AngleConstraint(Constraint):
    """
    Constrains the angle between two vectors.

    This constraint enforces that the angle formed by two vectors (defined by point
    pairs) remains at a specified target angle. Useful for maintaining joint angles or
    geometric relationships in suspension linkages.
    """

    def __init__(
        self,
        v1_start: PointID,
        v1_end: PointID,
        v2_start: PointID,
        v2_end: PointID,
        target_angle: float,
    ):
        """
        Initialize the angle constraint.

        Args:
            v1_start: Starting point of the first vector.
            v1_end: Ending point of the first vector.
            v2_start: Starting point of the second vector.
            v2_end: Ending point of the second vector.
            target_angle: The required angle between the vectors in radians.
        """
        self.v1_start = v1_start
        self.v1_end = v1_end
        self.v2_start = v2_start
        self.v2_end = v2_end
        self.target_angle = target_angle

    @property
    def involved_points(self) -> Set[PointID]:
        return {self.v1_start, self.v1_end, self.v2_start, self.v2_end}

    def residual(self, positions: dict[PointID, Vec3]) -> float:
        """
        Compute the angle residual.

        Returns the difference between the current angle and target angle in radians.
        Positive values indicate the angle is larger than the target.
        """
        v1 = positions[self.v1_end] - positions[self.v1_start]
        v2 = positions[self.v2_end] - positions[self.v2_start]

        current_angle = compute_vector_vector_angle(make_vec3(v1), make_vec3(v2))

        return float(current_angle - self.target_angle)


class FixedAxisConstraint(Constraint):
    """
    Constrains a point's coordinate on a cardinal axis.

    This constraint fixes a specific coordinate (X, Y, or Z) of a point to a constant
    value, useful for ground-fixed points or symmetry constraints in the suspension
    system.
    """

    def __init__(self, point_id: PointID, axis: Axis, value: float):
        """
        Initialize the fixed axis constraint.

        Args:
            point_id: The point whose coordinate is constrained.
            axis: The axis (X, Y, or Z) to constrain.
            value: The fixed coordinate value on the specified axis.
        """
        self.point_id = point_id
        self.axis = axis
        self.value = value

    @property
    def involved_points(self) -> Set[PointID]:
        return {self.point_id}

    def residual(self, positions: dict[PointID, Vec3]) -> float:
        """
        Compute the axis coordinate residual.

        Returns the difference between the current coordinate and the fixed value.
        Positive values indicate the coordinate is above the target.
        """
        point_coord = positions[self.point_id][self.axis]
        return float(point_coord - self.value)


class PointOnLineConstraint(Constraint):
    """
    Constrains a point to lie on an arbitrary line.

    This constraint enforces that a point remains on a specified infinite line defined
    by a point and direction vector. Useful for guiding points along linear paths or
    maintaining alignment in suspension mechanisms.
    """

    def __init__(
        self, point_id: PointID, line_point: np.ndarray, line_direction: np.ndarray
    ):
        """
        Initialize the point-on-line constraint.

        Args:
            point_id: The point that must lie on the line.
            line_point: A point on the line (3D numpy array).
            line_direction: The direction vector of the line (3D numpy array).
        """
        self.point_id = point_id
        self.line_point = line_point.copy()
        self.line_direction = line_direction.copy()

    @property
    def involved_points(self) -> Set[PointID]:
        return {self.point_id}

    def residual(self, positions: dict[PointID, Vec3]) -> float:
        """
        Compute the point-to-line distance residual.

        Returns the perpendicular distance from the point to the line. Zero indicates
        the point lies exactly on the line.
        """
        current_point = positions[self.point_id]

        # Vector from line point to current point.
        point_to_line = current_point - self.line_point

        # Distance from point to line using cross product.
        cross_product = np.cross(point_to_line, self.line_direction)
        direction_length = np.linalg.norm(self.line_direction)

        # Return actual physical distance.
        distance = np.linalg.norm(cross_product) / direction_length
        return float(distance)
</file>

<file path="src/kinematics/suspensions/registry.py">
"""
Suspension type registry.
"""

from __future__ import annotations

from typing import Tuple, Type

from kinematics.suspensions.core.provider import SuspensionProvider
from kinematics.suspensions.implementations.double_wishbone import (
    DoubleWishboneGeometry,
    DoubleWishboneProvider,
)
from kinematics.suspensions.implementations.macpherson import (
    MacPhersonGeometry,
    MacPhersonProvider,
)

# Registry type definitions.
ModelCls = Type[object]
ProviderCls = Type[SuspensionProvider]
Registry = dict[str, Tuple[ModelCls, ProviderCls]]


def build_registry() -> Registry:
    """
    Return the registry mapping suspension types to their classes.

    Returns:
        Dictionary mapping type strings to (ModelClass, ProviderClass) tuples.
    """
    return {
        "DOUBLE_WISHBONE": (DoubleWishboneGeometry, DoubleWishboneProvider),
        "MACPHERSON_STRUT": (MacPhersonGeometry, MacPhersonProvider),
    }
</file>

<file path="src/kinematics/main.py">
"""
Main orchestration functions for suspension kinematics.

This module provides high-level functions to coordinate the solving of suspension
geometries.
"""

from typing import List

from kinematics.points.derived.manager import DerivedPointsManager
from kinematics.solver import solve_sweep
from kinematics.state import SuspensionState
from kinematics.types import SweepConfig


def solve_suspension_sweep(
    geometry,
    provider_class,
    sweep_config: SweepConfig,
) -> List[SuspensionState]:
    """
    Orchestrates the solving of suspension kinematics for a parametric sweep.

    This function coordinates the complete process of solving suspension kinematics
    by instantiating the appropriate provider, setting up derived point calculations,
    and running the solver across target configurations.

    Args:
        geometry: The suspension geometry specification.
        provider_class: The SuspensionProvider class for this geometry type.
        sweep_config: Configuration for the parametric sweep.

    Returns:
        List of solved suspension states for each step in the sweep.
    """
    provider = provider_class(geometry)
    derived_spec = provider.derived_spec()
    derived_manager = DerivedPointsManager(derived_spec)

    kinematic_states = solve_sweep(
        initial_state=provider.initial_state(),
        constraints=provider.constraints(),
        sweep_config=sweep_config,
        derived_manager=derived_manager,
    )

    return kinematic_states
</file>

<file path="src/kinematics/solver.py">
"""
Kinematics solver using damped least squares.

This module provides functions to solve suspension kinematics by satisfying geometric
constraints and position targets using Levenberg-Marquardt.
"""

from typing import NamedTuple

import numpy as np
from scipy.optimize import least_squares

from kinematics.constants import (
    SOLVE_TOLERANCE_GRAD,
    SOLVE_TOLERANCE_STEP,
    SOLVE_TOLERANCE_VALUE,
)
from kinematics.constraints import Constraint
from kinematics.points.derived.manager import DerivedPointsManager
from kinematics.state import SuspensionState
from kinematics.targets import resolve_target
from kinematics.types import PointTarget, SweepConfig, TargetPositionMode
from kinematics.vector_utils.generic import project_coordinate

# Levenberg-Marquardt; damped least squares that can deal with the system being
# overdetermined (m > n), as may be the case with any redundant (but consistent)
# constraints.
SOLVE_METHOD = "lm"


class SolverConfig(NamedTuple):
    """
    Configuration parameters for the kinematic solver.

    Attributes:
        ftol (float): Tolerance for the function value convergence.
        xtol (float): Tolerance for the solution vector convergence.
        gtol (float): Tolerance for the gradient convergence.
        verbose (int): Verbosity level for the solver output.
    """

    ftol: float = SOLVE_TOLERANCE_VALUE
    xtol: float = SOLVE_TOLERANCE_STEP
    gtol: float = SOLVE_TOLERANCE_GRAD
    verbose: int = 0


class ResidualComputer:
    """
    Computes residuals for kinematic constraints and targets.

    This class explicitly holds a reference to a working state that it mutates
    during residual computation, making the data flow clear to readers and debuggers.

    Attributes:
        constraints: Geometric constraints to evaluate.
        derived_manager: Manager for computing derived points in-place.
        working_state: State object that is mutated during computation.
    """

    def __init__(
        self,
        constraints: list[Constraint],
        derived_manager: DerivedPointsManager,
        working_state: SuspensionState,
    ):
        self.constraints = constraints
        self.derived_manager = derived_manager
        self.working_state = working_state
        self.call_count = 0

    def compute(
        self,
        free_array: np.ndarray,
        step_targets: list[PointTarget],
    ) -> np.ndarray:
        """
        Compute residuals for the given free point positions and targets.

        This method mutates self.working_state in-place for performance.

        Args:
            free_array: Flattened array of free point coordinates.
            step_targets: Target constraints for this solve step.

        Returns:
            Array of residual values (constraints followed by targets).
        """
        # Update working state in-place with current guess.
        self.working_state.update_from_array(free_array)

        # Compute derived points in-place (avoids dict copy).
        self.derived_manager.update_in_place(self.working_state.positions)

        # Evaluate constraint residuals.
        residuals: list[float] = []
        for constraint in self.constraints:
            residuals.append(constraint.residual(self.working_state.positions))

        # Evaluate target residuals.
        for target in step_targets:
            direction = resolve_target(target.direction)
            current_pos = self.working_state.positions[target.point_id]
            current_coordinate = project_coordinate(current_pos, direction)
            residuals.append(current_coordinate - target.value)

        return np.array(residuals, dtype=float)


def resolve_targets_to_absolute(
    targets: list[PointTarget],
    initial_state: SuspensionState,
) -> list[PointTarget]:
    """
    Convert all targets to absolute coordinates.

    This function implements the "convert early" pattern: all mode-specific
    logic is handled here, once, before solving begins. The solver then works
    exclusively with absolute coordinates.

    Args:
        targets: List of targets in mixed modes (RELATIVE or ABSOLUTE)
        initial_state: Reference state for resolving RELATIVE targets

    Returns:
        List of targets with all modes converted to ABSOLUTE
    """
    resolved: list[PointTarget] = []

    for target in targets:
        if target.mode == TargetPositionMode.ABSOLUTE:
            resolved.append(target)
            continue

        # Convert a relative displacement to an absolute scalar coordinate along the
        # target direction: project the initial position onto the (unit) direction to
        # get the initial coordinate, then add the displacement.
        direction = resolve_target(target.direction)
        initial_pos = initial_state.positions[target.point_id]
        initial_coord = project_coordinate(initial_pos, direction)
        absolute_value = initial_coord + target.value

        # Create new target with absolute value and mode.
        resolved.append(
            PointTarget(
                point_id=target.point_id,
                direction=target.direction,
                value=absolute_value,
                mode=TargetPositionMode.ABSOLUTE,
            )
        )

    return resolved


def solve_sweep(
    initial_state: SuspensionState,
    constraints: list[Constraint],
    sweep_config: SweepConfig,
    derived_manager: DerivedPointsManager,
    solver_config: SolverConfig = SolverConfig(),
) -> list[SuspensionState]:
    """
    Solves a series of kinematic states by sweeping through target configurations using
    damped non-linear least squares. This function performs a sweep where each step in
    the sweep corresponds to a set of targets, solving sequentially from the initial
    state.

    Args:
        initial_state (SuspensionState): The initial suspension state to start the sweep from.
        constraints (list[Constraint]): List of geometric constraints to satisfy.
        sweep_config (SweepConfig): Configuration for the sweep, including number of steps and target sweeps.
        derived_manager (DerivedPointsManager): Manager to compute derived points in-place.
        solver_config (SolverConfig): Configuration parameters for the solver.

    Returns:
        list[SuspensionState]: List of solved suspension states for each step in the sweep.
    """
    # Convert all targets to absolute coordinates once before solving
    sweep_targets = [
        resolve_targets_to_absolute(
            [sweep[i] for sweep in sweep_config.target_sweeps], initial_state
        )
        for i in range(sweep_config.n_steps)
    ]

    # Working state reused across the sweep; mutated in-place for performance.
    working_state = initial_state.copy()

    # For each step in our sweep, we will keep a copy of the solved state; this is
    # our result dataset.
    solution_states: list[SuspensionState] = []

    # Residual computation utility; has explicit state reference and in-place derived
    # updates.
    residual_computer = ResidualComputer(
        constraints=constraints,
        derived_manager=derived_manager,
        working_state=working_state,
    )

    # Initial guess built from the working state's free points.
    x_0 = working_state.get_free_array()

    for step_targets in sweep_targets:
        n_vars = len(working_state.free_points_order) * 3
        m_res = len(constraints) + len(step_targets)

        if n_vars > m_res:
            raise ValueError(
                f"System is underdetermined (n_vars={n_vars} > m_res={m_res}). "
                "The solve method (Levenberg-Marquardt) requires at least as "
                "many residuals as variables."
            )

        result = least_squares(
            fun=residual_computer.compute,
            x0=x_0,
            args=(step_targets,),
            method=SOLVE_METHOD,
            ftol=solver_config.ftol,
            xtol=solver_config.xtol,
            gtol=solver_config.gtol,
            verbose=solver_config.verbose,
        )

        if not result.success:
            raise RuntimeError(
                f"Solver failed to converge for targets: {step_targets}."
                f"\nMessage: {result.message}"
            )

        # We now have to synchronize working_state with the accepted solution.
        # The solver may evaluate compute() at points near the solution for gradient
        # estimation or termination checks, then return us its best value, leaving
        # working_state at a different position to the actual solution.
        # We must explicitly update our scratchpad to result.x to ensure correctness.
        working_state.update_from_array(result.x)
        derived_manager.update_in_place(working_state.positions)

        # Store finalized state for this step.
        solution_states.append(working_state.copy())

        # The result becomes our local first guess for the next step.
        x_0 = result.x

    return solution_states


def solve(
    initial_state: SuspensionState,
    constraints: list[Constraint],
    targets: list[PointTarget],
    derived_manager: DerivedPointsManager,
    solver_config: SolverConfig = SolverConfig(),
) -> SuspensionState:
    """
    Solves for a single kinematic state using damped non-linear least squares. This
    function finds the suspension state that satisfies the given constraints and
    targets.

    Args:
        initial_state (SuspensionState): The initial suspension state.
        constraints (list[Constraint]): List of geometric constraints to satisfy.
        targets (list[PointTarget]): List of point targets to achieve.
        solver_config (SolverConfig): Configuration parameters for the solver.

    Returns:
        SuspensionState: The solved suspension state.
    """
    sweep_config = SweepConfig([targets])
    states = solve_sweep(
        initial_state=initial_state,
        constraints=constraints,
        sweep_config=sweep_config,
        derived_manager=derived_manager,
        solver_config=solver_config,
    )
    return states[0]
</file>

</files>
